Kafka의 개념을 **가장 높은 개념인 클러스터에서부터 가장 낮은 개념인 레코드 필드까지** 차례로 설명하고, 메시지 전송 프로세스에 대한 설명을 블로그 글 형식으로 작성해보겠습니다.

```bash
Kafka 클러스터
│
├── 브로커 1
│ ├── 토픽 A
│ │ ├── 파티션 1
│ │ │ ├── 리더 (메시지 저장 및 관리)
│ │ │ └── 팔로워 레플리카 (리더 복제)
│ │ └── 파티션 2
│ │ ├── 리더 (메시지 저장 및 관리)
│ │ └── 팔로워 레플리카 (리더 복제)
│ └── 토픽 B
│ ├── 파티션 1
│ │ ├── 리더 (메시지 저장 및 관리)
│ │ └── 팔로워 레플리카 (리더 복제)
│ └── 파티션 2
│ ├── 리더 (메시지 저장 및 관리)
│ └── 팔로워 레플리카 (리더 복제)
│
├── 브로커 2
│ ├── 토픽 A
│ │ ├── 파티션 1
│ │ │ ├── 리더 (메시지 저장 및 관리)
│ │ │ └── 팔로워 레플리카 (리더 복제)
│ │ └── 파티션 2
│ │ ├── 리더 (메시지 저장 및 관리)
│ │ └── 팔로워 레플리카 (리더 복제)
│ └── 토픽 B
│ ├── 파티션 1
│ │ ├── 리더 (메시지 저장 및 관리)
│ │ └── 팔로워 레플리카 (리더 복제)
│ └── 파티션 2
│ ├── 리더 (메시지 저장 및 관리)
│ └── 팔로워 레플리카 (리더 복제)
│
└── 브로커 3
├── 토픽 A
│ ├── 파티션 1
│ │ ├── 리더 (메시지 저장 및 관리)
│ │ └── 팔로워 레플리카 (리더 복제)
│ └── 파티션 2
│ ├── 리더 (메시지 저장 및 관리)
│ └── 팔로워 레플리카 (리더 복제)
└── 토픽 B
├── 파티션 1
│ ├── 리더 (메시지 저장 및 관리)
│ └── 팔로워 레플리카 (리더 복제)
└── 파티션 2
├── 리더 (메시지 저장 및 관리)
└── 팔로워 레플리카 (리더 복제)

---

Kafka 메시지 구조
│
├── 레코드 배치 (Record Batch)
│ ├── 레코드 1 (Record)
│ │ ├── 키 (Key) - 파티션 할당에 사용됨
│ │ ├── 값 (Value) - 메시지 내용
│ │ ├── 타임스탬프 (Timestamp) - 메시지 생성 또는 기록 시간
│ │ └── 헤더 (Header) - 추가 메타데이터 (키-값 쌍)
│ ├── 레코드 2 (Record)
│ │ ├── 키 (Key) - 파티션 할당에 사용됨
│ │ ├── 값 (Value) - 메시지 내용
│ │ ├── 타임스탬프 (Timestamp) - 메시지 생성 또는 기록 시간
│ │ └── 헤더 (Header) - 추가 메타데이터 (키-값 쌍)
│ └── ...
│
└── 레코드 N (Record)
├── 키 (Key) - 파티션 할당에 사용됨
├── 값 (Value) - 메시지 내용
├── 타임스탬프 (Timestamp) - 메시지 생성 또는 기록 시간
└── 헤더 (Header) - 추가 메타데이터 (키-값 쌍)

---

```

## Kafka 클러스터 구조와 메시지 전송 프로세스

Apache Kafka는 대규모 데이터 스트림을 처리하기 위한 **분산 메시징 시스템**으로, 데이터의 일관성과 내구성을 보장하면서도 높은 처리 성능을 제공합니다. Kafka의 구조는 크게 **클러스터**부터 시작하여 가장 작은 단위인 **레코드의 필드**까지 다양한 구성 요소로 이루어져 있으며, 이 구조가 데이터 전송 및 관리에 중요한 역할을 합니다.

---

### 1. Kafka 클러스터 (Kafka Cluster)

Kafka 클러스터는 Kafka 시스템의 최상위 개념으로, **여러 개의 브로커(Broker)가 모여 구성된 서버 집합**입니다. 클러스터는 분산된 데이터 저장 및 관리 시스템을 제공하며, 고가용성과 내구성을 보장합니다. 각 브로커는 특정 데이터를 저장하고, 클러스터 내에서 데이터가 적절히 분산될 수 있도록 관리됩니다. 이로 인해 Kafka 클러스터는 대규모 데이터의 안정적인 저장과 빠른 전송을 지원합니다.

---

### 2. 브로커 (Broker)

브로커는 Kafka 클러스터를 구성하는 개별 서버로, 데이터 저장과 전송 요청을 처리합니다. 각 브로커는 하나 이상의 **토픽**과 **파티션**을 관리하고, 다른 브로커와 협력하여 **데이터 분산 처리와 중복 저장**을 담당합니다. Kafka 클러스터 내에서는 여러 브로커가 역할을 분담하며, 각 브로커가 처리하는 데이터를 고르게 분산하여 대용량 데이터를 효율적으로 처리합니다.

---

### 3. 토픽 (Topic)

토픽은 **Kafka에서 데이터가 저장되는 논리적인 구분 단위**입니다. 애플리케이션이 특정 주제의 데이터를 전송하거나 구독할 수 있도록 도와주며, 같은 종류의 데이터를 담는 컨테이너 역할을 합니다. 예를 들어, `user_activity` 토픽은 사용자 활동 로그를 저장하고, `order_data` 토픽은 주문 정보를 저장할 수 있습니다. 토픽은 여러 개의 파티션으로 나누어져 데이터가 병렬로 저장되고, 병렬 처리가 가능합니다.

---

### 4. 파티션 (Partition)

파티션은 각 토픽을 물리적으로 분할한 단위로, **데이터의 병렬 처리와 확장성을 높이는 역할**을 합니다. Kafka는 파티션 단위로 데이터를 저장하며, 각 파티션 내에서는 메시지 순서가 보장됩니다. 이를 통해 여러 개의 컨슈머가 하나의 토픽을 병렬로 처리할 수 있습니다. 또한, 파티션은 장애 발생 시에도 데이터를 안전하게 복구할 수 있도록 리더-팔로워 구조로 구성됩니다.

---

### 5. 리더와 팔로워 레플리카 (Leader and Follower Replica)

Kafka의 각 파티션은 **리더와 하나 이상의 팔로워 레플리카**로 구성됩니다. **리더**는 파티션의 주 인스턴스로, 모든 읽기와 쓰기 요청을 처리합니다. 반면, **팔로워 레플리카**는 리더의 데이터를 복제하여 보관하며, 리더가 장애가 발생할 경우 팔로워 중 하나가 리더로 승격됩니다. 이를 통해 Kafka는 데이터의 내구성과 고가용성을 보장할 수 있습니다.

---

### 6. 메시지 (Message)

메시지는 Kafka를 통해 애플리케이션 간에 전송되는 **데이터의 기본 단위**입니다. 일반적으로 메시지는 **레코드(Record)**라고도 하며, 이 레코드가 여러 개 모여 **레코드 배치(Record Batch)**로 전송됩니다. 메시지는 데이터 전송의 실질적인 내용을 담고 있으며, 레코드 배치로 묶여 브로커에 효율적으로 전달됩니다.

---

### 7. 레코드 배치 (Record Batch)

레코드 배치는 **여러 개의 레코드를 묶어 전송하는 단위**로, Kafka는 네트워크 성능을 최적화하기 위해 데이터를 배치로 묶어 전송합니다. 레코드 배치는 압축 및 일괄 처리가 가능하여 대규모 데이터를 효율적으로 처리할 수 있습니다.

---

### 8. 레코드 (Record)

Kafka의 레코드는 메시지의 실제 데이터 단위로, `키(Key)`, `값(Value)`, `타임스탬프(Timestamp)`, `헤더(Header)` 등의 필드를 포함합니다. 각 레코드는 파티션 내에서 고유한 **오프셋(Offset)**을 가지며, 이 오프셋을 기준으로 순차적으로 읽거나 처리할 수 있습니다.

---

### 9. 레코드 필드 (Record Fields)

- **키 (Key)**: 메시지를 특정 파티션에 할당할 때 사용되는 필드로, 같은 키를 가진 메시지는 동일한 파티션에 저장됩니다.
- **값 (Value)**: 실제 메시지 내용이 담긴 필드로, 애플리케이션 간의 전송 데이터 본문에 해당합니다.
- **타임스탬프 (Timestamp)**: 메시지가 생성되거나 Kafka에 기록된 시간을 나타내며, 메시지의 순서나 재처리 시점을 추적할 수 있습니다.
- **헤더 (Header)**: 추가적인 메타데이터를 포함하는 필드로, `키-값` 형태의 데이터를 담아 메시지 처리 로직에 도움을 줄 수 있습니다.

---

## Kafka 메시지 전송 프로세스

Kafka의 메시지 전송은 다음과 같은 순서로 이루어집니다:

1. **프로듀서가 메시지를 생성**: 프로듀서 애플리케이션은 메시지(레코드)를 생성하며, 각 메시지에는 키, 값, 타임스탬프, 헤더와 같은 정보가 포함될 수 있습니다.

2. **레코드 배치로 묶어 전송**: 프로듀서는 여러 개의 메시지를 **레코드 배치**로 묶어 브로커로 전송합니다. 이 배치 전송 방식은 성능을 최적화하고 네트워크 비용을 절감하는 데 도움을 줍니다.

3. **리더에게 전송**: 프로듀서는 **특정 파티션의 리더**에게 배치를 전송합니다. Kafka는 메시지의 키 또는 라운드 로빈 방식으로 파티션을 결정하며, 리더는 이 데이터를 저장하고 관리합니다.

4. **팔로워 레플리카로 복제**: 리더가 데이터를 수신한 후, 이를 동일한 파티션의 팔로워 레플리카에 복제합니다. 이로 인해 데이터의 내구성이 보장되고, 장애 발생 시에도 데이터 손실을 최소화할 수 있습니다.

5. **컨슈머가 리더로부터 메시지를 읽음**: Kafka의 컨슈머 애플리케이션은 파티션 내의 리더에서 데이터를 읽으며, 오프셋을 통해 데이터를 순차적으로 처리할 수 있습니다. Kafka는 각 컨슈머의 오프셋을 추적하여 중단된 지점에서 다시 읽을 수 있도록 지원합니다.

이와 같은 전송 구조 덕분에 Kafka는 **고성능, 고가용성, 데이터 내구성**을 동시에 유지하며 대규모 데이터 스트림을 안정적으로 처리할 수 있습니다.
