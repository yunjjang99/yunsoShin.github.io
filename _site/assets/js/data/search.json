[
  
  {
    "title": "NestJS와 Angular: 철학과 설계의 유사성",
    "url": "/posts/NestJS%EC%99%80-Angular-%EC%B2%A0%ED%95%99%EA%B3%BC-%EC%84%A4%EA%B3%84%EC%9D%98-%EC%9C%A0%EC%82%AC%EC%84%B1/",
    "categories": "NestJS, Angular",
    "tags": "web framework, typescript",
    "date": "2024-06-18 00:00:00 +0900",
    





    
    "snippet": "NestJS는 Node.js를 위한 진보된 웹 프레임워크로, Angular의 철학과 디자인 패턴에 깊은 영향을 받아 개발되었습니다. 이는 두 프레임워크가 구조화된 모듈 시스템, 의존성 주입, 데코레이터 사용 등에서 많은 유사성을 가지게 합니다. 아래에서는 NestJS와 Angular의 주요 개념을 비교하면서, 코드 예제를 통해 구체적으로 설명해 보겠습...",
    "content": "NestJS는 Node.js를 위한 진보된 웹 프레임워크로, Angular의 철학과 디자인 패턴에 깊은 영향을 받아 개발되었습니다. 이는 두 프레임워크가 구조화된 모듈 시스템, 의존성 주입, 데코레이터 사용 등에서 많은 유사성을 가지게 합니다. 아래에서는 NestJS와 Angular의 주요 개념을 비교하면서, 코드 예제를 통해 구체적으로 설명해 보겠습니다.목차  모듈 시스템  의존성 주입 (Dependency Injection)  데코레이터 사용  파이프 (Pipes)  가드 (Guards)  인터셉터 (Interceptors)  미들웨어 (Middleware)  라우팅 (Routing)  테스트 (Testing)  커스텀 데코레이터 (Custom Decorators)  라이프사이클 훅 (Lifecycle Hooks)  결론모듈 시스템AngularAngular에서는 모듈이 @NgModule 데코레이터로 정의됩니다. 모듈은 컴포넌트, 서비스, 다른 모듈 등을 그룹화하여 애플리케이션을 구조화합니다.// Angular의 AppModuleimport { NgModule } from \"@angular/core\";import { BrowserModule } from \"@angular/platform-browser\";import { AppComponent } from \"./app.component\";@NgModule({  declarations: [AppComponent],  imports: [BrowserModule],  providers: [],  bootstrap: [AppComponent]})export class AppModule {}NestJSNestJS에서도 모듈이 @Module 데코레이터로 정의되며, 컨트롤러, 서비스, 다른 모듈 등을 포함합니다.// NestJS의 AppModuleimport { Module } from \"@nestjs/common\";import { AppController } from \"./app.controller\";import { AppService } from \"./app.service\";@Module({  imports: [],  controllers: [AppController],  providers: [AppService]})export class AppModule {}의존성 주입 (Dependency Injection)AngularAngular는 의존성 주입을 통해 컴포넌트나 서비스에 필요한 의존성을 주입합니다. @Injectable 데코레이터를 사용하여 서비스를 정의합니다.// Angular의 Serviceimport { Injectable } from \"@angular/core\";@Injectable({  providedIn: \"root\"})export class DataService {  constructor() {}  getData() {    return \"Hello Angular\";  }}// Angular의 Componentimport { Component } from \"@angular/core\";import { DataService } from \"./data.service\";@Component({  selector: \"app-root\",  template: ``})export class AppComponent {  data: string;  constructor(private dataService: DataService) {    this.data = this.dataService.getData();  }}NestJSNestJS는 Angular와 유사하게 @Injectable 데코레이터를 사용하여 서비스를 정의하고, 의존성을 주입합니다.// NestJS의 Serviceimport { Injectable } from \"@nestjs/common\";@Injectable()export class AppService {  getHello(): string {    return \"Hello NestJS\";  }}// NestJS의 Controllerimport { Controller, Get } from \"@nestjs/common\";import { AppService } from \"./app.service\";@Controller()export class AppController {  constructor(private readonly appService: AppService) {}  @Get()  getHello(): string {    return this.appService.getHello();  }}데코레이터 사용AngularAngular는 데코레이터를 사용하여 컴포넌트, 디렉티브, 파이프, 서비스 등을 정의합니다.// Angular의 Component 데코레이터import { Component } from \"@angular/core\";@Component({  selector: \"app-root\",  templateUrl: \"./app.component.html\",  styleUrls: [\"./app.component.css\"]})export class AppComponent {  title = \"app\";}NestJSNestJS는 데코레이터를 사용하여 컨트롤러, 라우트 핸들러, 모듈 등을 정의합니다.// NestJS의 Controller 데코레이터import { Controller, Get } from \"@nestjs/common\";@Controller(\"cats\")export class CatsController {  @Get()  findAll(): string {    return \"This action returns all cats\";  }}파이프 (Pipes)AngularAngular에서 파이프는 데이터를 변환하는 데 사용됩니다. 예를 들어, 날짜 형식을 변환하거나 텍스트를 소문자로 바꾸는 데 사용됩니다.// Angular의 파이프import { Pipe, PipeTransform } from \"@angular/core\";@Pipe({  name: \"capitalize\"})export class CapitalizePipe implements PipeTransform {  transform(value: string): string {    return value.charAt(0).toUpperCase() + value.slice(1);  }}NestJSNestJS에서도 파이프는 유효성 검사와 변환을 위해 사용됩니다. 예를 들어, 요청 데이터를 검증하거나 변환하는 데 사용됩니다.// NestJS의 파이프import {  PipeTransform,  Injectable,  ArgumentMetadata,  BadRequestException} from \"@nestjs/common\";@Injectable()export class ParseIntPipe implements PipeTransform&lt;string, number&gt; {  transform(value: string, metadata: ArgumentMetadata): number {    const val = parseInt(value, 10);    if (isNaN(val)) {      throw new BadRequestException(\"Validation failed\");    }    return val;  }}가드 (Guards)AngularAngular에서는 라우트 가드를 사용하여 특정 경로에 접근하기 전에 사용자의 인증 상태를 확인할 수 있습니다.// Angular의 AuthGuardimport { Injectable } from \"@angular/core\";import { CanActivate, Router } from \"@angular/router\";import { AuthService } from \"./auth.service\";@Injectable({  providedIn: \"root\"})export class AuthGuard implements CanActivate {  constructor(private authService: AuthService, private router: Router) {}  canActivate(): boolean {    if (this.authService.isLoggedIn()) {      return true;    } else {      this.router.navigate([\"login\"]);      return false;    }  }}NestJSNestJS에서도 가드는 요청이 처리되기 전에 특정 조건을 확인하는 데 사용됩니다. 주로 인증 및 권한 부여를 위해 사용됩니다.// NestJS의 AuthGuardimport { Injectable, CanActivate, ExecutionContext } from \"@nestjs/common\";import { Observable } from \"rxjs\";@Injectable()export class AuthGuard implements CanActivate {  canActivate(    context: ExecutionContext  ): boolean | Promise&lt;boolean&gt; | Observable&lt;boolean&gt; {    const request = context.switchToHttp().getRequest();    return validateRequest(request);  }}function validateRequest(request: any): boolean {  // 인증 로직을 여기에 추가  return true;}인터셉터 (Interceptors)AngularAngular에서 HTTP 인터셉터는 모든 HTTP 요청 및 응답을 가로채서 처리할 수 있습니다. 예를 들어, 공통 헤더를 추가하거나 오류를 처리하는 데 사용됩니다.// Angular의 HTTP 인터셉터import { Injectable } from \"@angular/core\";import {  HttpEvent,  HttpInterceptor,  HttpHandler,  HttpRequest} from \"@angular/common/http\";import { Observable } from \"rxjs\";@Injectable()export class AuthInterceptor implements HttpInterceptor {  intercept(    req: HttpRequest&lt;any&gt;,    next: HttpHandler  ): Observable&lt;HttpEvent&lt;any&gt;&gt; {    const authToken = \"my-auth-token\";    const authReq = req.clone({      headers: req.headers.set(\"Authorization\", `Bearer ${authToken}`)    });    return next.handle(authReq);  }}NestJSNestJS에서 인터셉터는 요청 및 응답을 가로채서 처리할 수 있습니다. 예를 들어, 로깅, 캐싱, 응답 데이터 변환 등을 처리할 수 있습니다.// NestJS의 인터셉터import {  Injectable,  NestInterceptor,  ExecutionContext,  CallHandler} from \"@nestjs/common\";import { Observable } from \"rxjs\";import { map } from \"rxjs/operators\";@Injectable()export class TransformInterceptor implements NestInterceptor {  intercept(context: ExecutionContext, next: CallHandler): Observable&lt;any&gt; {    return next.handle().pipe(map((data) =&gt; ({ data })));  }}미들웨어 (Middleware)AngularAngular는 미들웨어 개념이 없지만, 서비스나 다른 기법을 사용하여 비슷한 기능을 구현할 수 있습니다.NestJSNestJS에서는 미들웨어를 사용하여 요청 처리 전에 특정 작업을 수행할 수 있습니다.// NestJS의 미들웨어import { Injectable, NestMiddleware } from \"@nestjs/common\";import { Request, Response, NextFunction } from \"express\";@Injectable()export class LoggerMiddleware implements NestMiddleware {  use(req: Request, res: Response, next: NextFunction) {    console.log(`Request...`);    next();  }}라우팅 (Routing)AngularAngular는 @angular/router 모듈을 통해 클라이언트 사이드 라우팅을 지원합니다. 이를 통해 URL 경로에 따라 컴포넌트를 로드할 수 있습니다.// Angular의 라우팅 설정import { NgModule } from \"@angular/core\";import { RouterModule, Routes } from \"@angular/router\";import { HomeComponent } from \"./home/home.component\";import { AboutComponent } from \"./about/about.component\";const routes: Routes = [  { path: \"\", component: HomeComponent },  { path: \"about\", component: AboutComponent }];@NgModule({  imports: [RouterModule.forRoot(routes)],  exports: [RouterModule]})export class AppRoutingModule {}NestJSNestJS는 @nestjs/common 모듈을 통해 서버 사이드 라우팅을 지원합니다. 컨트롤러를 통해 URL 경로를 정의하고 핸들러를 지정할 수 있습니다.// NestJS의 라우팅 설정import { Controller, Get } from \"@nestjs/common\";@Controller(\"home\")export class HomeController {  @Get()  getHome(): string {    return \"Welcome to Home\";  }}@Controller(\"about\")export class AboutController {  @Get()  getAbout(): string {    return \"About Us\";  }}테스트 (Testing)AngularAngular는 Jasmine과 Karma를 통해 테스트 프레임워크를 제공합니다. 이를 통해 컴포넌트, 서비스 등을 단위 테스트할 수 있습니다.// Angular의 테스트 예제import { TestBed } from \"@angular/core/testing\";import { AppComponent } from \"./app.component\";describe(\"AppComponent\", () =&gt; {  beforeEach(async () =&gt; {    await TestBed.configureTestingModule({      declarations: [AppComponent]    }).compileComponents();  });  it(\"should create the app\", () =&gt; {    const fixture = TestBed.createComponent(AppComponent);    const app = fixture.componentInstance;    expect(app).toBeTruthy();  });});NestJSNestJS는 Jest를 통해 테스트 프레임워크를 제공합니다. 이를 통해 컨트롤러, 서비스 등을 단위 테스트할 수 있습니다.// NestJS의 테스트 예제import { Test, TestingModule } from \"@nestjs/testing\";import { AppController } from \"./app.controller\";import { AppService } from \"./app.service\";describe(\"AppController\", () =&gt; {  let appController: AppController;  beforeEach(async () =&gt; {    const app: TestingModule = await Test.createTestingModule({      controllers: [AppController],      providers: [AppService]    }).compile();    appController = app.get&lt;AppController&gt;(AppController);  });  it('should return \"Hello World!\"', () =&gt; {    expect(appController.getHello()).toBe(\"Hello World!\");  });});커스텀 데코레이터 (Custom Decorators)AngularAngular에서는 커스텀 데코레이터를 사용하여 클래스, 메서드, 속성에 메타데이터를 추가할 수 있습니다.// Angular의 커스텀 데코레이터function Log(target: any, propertyKey: string, descriptor: PropertyDescriptor) {  const originalMethod = descriptor.value;  descriptor.value = function (...args: any[]) {    console.log(      `Method ${propertyKey} called with args: ${JSON.stringify(args)}`    );    return originalMethod.apply(this, args);  };  return descriptor;}class ExampleService {  @Log  exampleMethod(arg1: string, arg2: number) {    return `${arg1} - ${arg2}`;  }}NestJSNestJS에서도 커스텀 데코레이터를 사용하여 라우트 핸들러에 메타데이터를 추가할 수 있습니다.// NestJS의 커스텀 데코레이터import { SetMetadata } from \"@nestjs/common\";export const Roles = (...roles: string[]) =&gt; SetMetadata(\"roles\", roles);import { Controller, Get } from \"@nestjs/common\";import { Roles } from \"./roles.decorator\";@Controller(\"users\")export class UserController {  @Get()  @Roles(\"admin\")  findAll() {    return \"This route is restricted to admin roles\";  }}라이프사이클 훅 (Lifecycle Hooks)AngularAngular는 컴포넌트의 생명주기 동안 특정 시점에 호출되는 여러 라이프사이클 훅을 제공합니다.// Angular의 라이프사이클 훅import { Component, OnInit, OnDestroy } from \"@angular/core\";@Component({  selector: \"app-example\",  template: `&lt;p&gt;Example component&lt;/p&gt;`})export class ExampleComponent implements OnInit, OnDestroy {  ngOnInit() {    console.log(\"Component initialized\");  }  ngOnDestroy() {    console.log(\"Component destroyed\");  }}NestJSNestJS는 모듈, 컨트롤러, 프로바이더 등의 생명주기 동안 특정 시점에 호출되는 여러 라이프사이클 훅을 제공합니다.// NestJS의 라이프사이클 훅import { Injectable, OnModuleInit, OnModuleDestroy } from \"@nestjs/common\";@Injectable()export class ExampleService implements OnModuleInit, OnModuleDestroy {  onModuleInit() {    console.log(\"Module initialized\");  }  onModuleDestroy() {    console.log(\"Module destroyed\");  }}결론NestJS는 Angular의 디자인 패턴을 채택하여, 엔터프라이즈 애플리케이션을 위한 견고한 아키텍처를 제공합니다. 모듈 시스템, 의존성 주입, 데코레이터의 사용 등에서 Angular와 많은 유사성을 보여줍니다. 이를 통해 개발자들은 Angular와 유사한 방식으로 NestJS 애플리케이션을 구조화하고, 쉽게 유지 보수할 수 있습니다.추가 설명환경Angular: 클라이언트 사이드 프레임워크로, 브라우저에서 동작하는 애플리케이션을 만듭니다. 주로 컴포넌트 기반으로 UI를 구축합니다.NestJS: 서버 사이드 프레임워크로, Node.js 환경에서 동작하는 백엔드 애플리케이션을 만듭니다. 주로 컨트롤러, 서비스 기반으로 비즈니스 로직을 구축합니다.의존성 등록Angular: 서비스는 providedIn 속성을 통해 모듈, 컴포넌트, 루트 등 여러 레벨에 등록될 수 있습니다.@Injectable({  providedIn: \"root\"})export class DataService {}NestJS: 서비스는 @Module 데코레이터의 providers 배열에 명시적으로 등록됩니다.@Module({  providers: [AppService]})export class AppModule {}사용 방식Angular: 컴포넌트에서 서비스 주입.constructor(private dataService: DataService) {}NestJS: 컨트롤러나 다른 서비스에서 서비스 주입.constructor(private readonly appService: AppService) {}"
  },
  
  {
    "title": "Jest로 테스트코드 작성하기: 상세 가이드와 예제 코드",
    "url": "/posts/JEST%EB%A1%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%BD%94%EB%93%9C-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0-%EC%83%81%EC%84%B8-%EA%B0%80%EC%9D%B4%EB%93%9C%EC%99%80-%EC%98%88%EC%A0%9C-%EC%BD%94%EB%93%9C/",
    "categories": "",
    "tags": "",
    "date": "2024-06-03 00:00:00 +0900",
    





    
    "snippet": "layout: posttitle: “JEST로 테스트코드 작성하기: 상세 가이드와 예제 코드”date: 2024-06-03categories: [JavaScript, Testing]tags: [Jest, TDD]JavaScript 프로젝트에서 테스트를 작성하는 것은 코드의 품질을 유지하고, 예상치 못한 버그를 방지하는 데 중요한 역할을 합니다. Jes...",
    "content": "layout: posttitle: “JEST로 테스트코드 작성하기: 상세 가이드와 예제 코드”date: 2024-06-03categories: [JavaScript, Testing]tags: [Jest, TDD]JavaScript 프로젝트에서 테스트를 작성하는 것은 코드의 품질을 유지하고, 예상치 못한 버그를 방지하는 데 중요한 역할을 합니다. Jest는 Facebook에서 개발한 JavaScript 테스팅 프레임워크로, 설정이 간단하고 다양한 기능을 제공하여 많은 개발자들이 애용하고 있습니다. 이번 블로그 글에서는 Jest를 사용하여 테스트 코드를 작성하는 방법을 자세히 설명하고, 풍부한 예제 코드로 그 과정을 보여드리겠습니다.1. Jest 설치하기먼저, Jest를 프로젝트에 설치해야 합니다. npm을 사용하여 간단히 설치할 수 있습니다:npm install --save-dev jest설치 후, package.json 파일의 scripts 섹션에 Jest를 추가합니다:{  \"scripts\": {    \"test\": \"jest\"  }}이제 npm test 명령어로 Jest 테스트를 실행할 수 있습니다.2. 기본 테스트 작성하기Jest의 기본적인 사용법을 이해하기 위해 간단한 테스트를 작성해보겠습니다. 예제로 사용할 함수는 두 숫자를 더하는 함수입니다:// sum.jsfunction sum(a, b) {  return a + b;}module.exports = sum;이제 이 함수에 대한 테스트 코드를 작성해봅시다:// sum.test.jsconst sum = require(\"./sum\");test(\"adds 1 + 2 to equal 3\", () =&gt; {  expect(sum(1, 2)).toBe(3);});이 테스트는 sum 함수가 1과 2를 더하여 3이 되는지 확인합니다. test 함수는 테스트 케이스를 정의하고, expect 함수는 실제 값이 예상 값과 일치하는지 확인합니다.3. 다양한 매처 사용하기Jest는 다양한 매처(matcher)를 제공하여 다양한 방식으로 값을 검증할 수 있습니다. 몇 가지 예제를 살펴보겠습니다:// matchers.test.jstest(\"two plus two is four\", () =&gt; {  expect(2 + 2).toBe(4);});test(\"object assignment\", () =&gt; {  const data = { one: 1 };  data[\"two\"] = 2;  expect(data).toEqual({ one: 1, two: 2 });});test(\"null\", () =&gt; {  const n = null;  expect(n).toBeNull();  expect(n).toBeDefined();  expect(n).not.toBeUndefined();  expect(n).not.toBeTruthy();  expect(n).toBeFalsy();});test(\"zero\", () =&gt; {  const z = 0;  expect(z).not.toBeNull();  expect(z).toBeDefined();  expect(z).not.toBeUndefined();  expect(z).not.toBeTruthy();  expect(z).toBeFalsy();});4. 비동기 코드 테스트하기비동기 코드를 테스트할 때는 async/await를 사용하거나, done 콜백을 사용할 수 있습니다. 다음은 async/await를 사용하는 예제입니다:// async.jsfunction fetchData() {  return new Promise((resolve) =&gt; {    setTimeout(() =&gt; {      resolve(\"peanut butter\");    }, 1000);  });}module.exports = fetchData;// async.test.jsconst fetchData = require(\"./async\");test(\"the data is peanut butter\", async () =&gt; {  const data = await fetchData();  expect(data).toBe(\"peanut butter\");});5. Mock 함수 사용하기Mock 함수를 사용하면 함수 호출 여부, 호출 횟수, 호출된 인수 등을 확인할 수 있습니다. 예를 들어, 다음과 같은 모듈이 있다고 가정해봅시다:// forEach.jsfunction forEach(items, callback) {  for (let index = 0; index &lt; items.length; index++) {    callback(items[index]);  }}module.exports = forEach;이제 이 모듈을 테스트할 때 mock 함수를 사용해보겠습니다:// forEach.test.jsconst forEach = require(\"./forEach\");test(\"mock callback\", () =&gt; {  const mockCallback = jest.fn((x) =&gt; 42 + x);  forEach([0, 1], mockCallback);  // 콜백 함수가 두 번 호출되었는지 확인  expect(mockCallback.mock.calls.length).toBe(2);  // 첫 번째 호출 시 첫 번째 인수가 0이었는지 확인  expect(mockCallback.mock.calls[0][0]).toBe(0);  // 두 번째 호출 시 첫 번째 인수가 1이었는지 확인  expect(mockCallback.mock.calls[1][0]).toBe(1);  // 첫 번째 호출의 반환 값이 42였는지 확인  expect(mockCallback.mock.results[0].value).toBe(42);});6. 테스트 커버리지 확인하기Jest는 코드 커버리지를 확인할 수 있는 기능도 제공합니다. 다음 명령어를 실행하면 커버리지 보고서를 생성할 수 있습니다:npm test -- --coveragecoverage 폴더에 HTML 형식의 커버리지 보고서가 생성되며, 이를 통해 어느 부분이 테스트되었는지 쉽게 확인할 수 있습니다.현업에서 TDD(Test-Driven Development) 구현하기: Jest를 활용한 사례TDD(Test-Driven Development, 테스트 주도 개발)는 코드 작성 전에 테스트를 먼저 작성하는 방식입니다. TDD를 통해 코드를 작성하면 더 높은 코드 품질과 유지보수성을 확보할 수 있습니다. 이번 포스팅에서는 Jest를 활용하여 현업에서 TDD를 구현하는 방법을 알아보겠습니다.1. TDD의 기본 흐름TDD의 기본적인 흐름은 다음과 같습니다:  테스트 작성 (Red): 실패하는 테스트를 작성합니다.  코드 작성 (Green): 테스트를 통과하기 위한 최소한의 코드를 작성합니다.  리팩토링 (Refactor): 코드의 중복을 제거하고, 더 나은 구조로 리팩토링합니다.이러한 과정을 반복하여 기능을 구현해 나갑니다.2. 예제 프로젝트: Todo 리스트 애플리케이션간단한 Todo 리스트 애플리케이션을 TDD 방식으로 구현해보겠습니다. 기능 요구 사항은 다음과 같습니다:  Todo 항목을 추가할 수 있다.  Todo 항목을 완료 처리할 수 있다.  완료된 Todo 항목을 삭제할 수 있다.2.1 테스트 작성 (Red)먼저, 각 기능에 대한 테스트를 작성합니다.// todo.test.jsconst TodoList = require(\"./todo\");test(\"should add a todo item\", () =&gt; {  const todoList = new TodoList();  todoList.add(\"Learn TDD\");  expect(todoList.getItems()).toEqual([{ text: \"Learn TDD\", done: false }]);});test(\"should mark a todo item as done\", () =&gt; {  const todoList = new TodoList();  todoList.add(\"Learn TDD\");  todoList.markDone(\"Learn TDD\");  expect(todoList.getItems()).toEqual([{ text: \"Learn TDD\", done: true }]);});test(\"should remove a completed todo item\", () =&gt; {  const todoList = new TodoList();  todoList.add(\"Learn TDD\");  todoList.markDone(\"Learn TDD\");  todoList.remove(\"Learn TDD\");  expect(todoList.getItems()).toEqual([]);});2.2 코드 작성 (Green)테스트를 통과하기 위한 최소한의 코드를 작성합니다.// todo.jsclass TodoList {  constructor() {    this.items = [];  }  add(text) {    this.items.push({ text, done: false });  }  getItems() {    return this.items;  }  markDone(text) {    const item = this.items.find((item) =&gt; item.text === text);    if (item) {      item.done = true;    }  }  remove(text) {    this.items = this.items.filter((item) =&gt; item.text !== text || !item.done);  }}module.exports = TodoList;2.3 리팩토링 (Refactor)코드를 개선하여 중복을 제거하고 구조를 개선합니다. 현재 예제에서는 간단한 코드이므로 추가적인 리팩토링이 필요하지 않습니다.3. 비동기 코드 테스트하기 (Jest)비동기 코드를 테스트할 때는 async/await를 사용하거나, done 콜백을 사용할 수 있습니다. 비동기 작업이 완료되기 전에 테스트가 종료되지 않도록 주의해야 합니다. 다음은 비동기 코드 테스트 예제입니다:// asyncTodo.jsclass AsyncTodoList {  constructor() {    this.items = [];  }  async add(text) {    return new Promise((resolve) =&gt; {      setTimeout(() =&gt; {        this.items.push({ text, done: false });        resolve();      }, 1000);    });  }  getItems() {    return this.items;  }}module.exports = AsyncTodoList;// asyncTodo.test.jsconst AsyncTodoList = require(\"./asyncTodo\");test(\"should add a todo item asynchronously\", async () =&gt; {  const todoList = new AsyncTodoList();  await todoList.add(\"Learn TDD\");  expect(todoList.getItems()).toEqual([{ text: \"Learn TDD\", done: false }]);});4. Mock 함수 사용하기 (Jest)Mock 함수는 함수 호출 여부, 호출 횟수, 호출된 인수 등을 확인할 수 있습니다. 외부 API 호출이나 복잡한 비즈니스 로직을 단위 테스트할 때 유용합니다. 다음은 Mock 함수를 사용하는 예제입니다:// externalApi.jsclass ExternalApi {  fetchData(callback) {    setTimeout(() =&gt; {      callback(\"data\");    }, 1000);  }}module.exports = ExternalApi;// externalApi.test.jsconst ExternalApi = require(\"./externalApi\");test(\"should fetch data from external API\", () =&gt; {  const api = new ExternalApi();  const callback = jest.fn();  api.fetchData(callback);  jest.runAllTimers();  expect(callback).toHaveBeenCalledTimes(1);  expect(callback).toHaveBeenCalledWith(\"data\");});"
  },
  
  {
    "title": "리액트의 Reconciliation 과정 설명",
    "url": "/posts/react-%EA%B0%80%EC%83%81%EB%8F%94%EC%9D%98-%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC/",
    "categories": "React, Frontend",
    "tags": "Reconciliation, Virtual DOM, React",
    "date": "2024-06-01 00:00:00 +0900",
    





    
    "snippet": "리액트의 Reconciliation 과정에서는 변경된 부분만 실제 DOM에 반영됩니다. 주어진 코드에서 상태(state)가 변경되면 리액트는 Reconciliation 과정을 통해 변경된 부분만을 찾아서 업데이트합니다. 이를 Raw한 단계로 설명해보겠습니다.코드 예제: ParentComponent와 ChildComponentfunction Parent...",
    "content": "리액트의 Reconciliation 과정에서는 변경된 부분만 실제 DOM에 반영됩니다. 주어진 코드에서 상태(state)가 변경되면 리액트는 Reconciliation 과정을 통해 변경된 부분만을 찾아서 업데이트합니다. 이를 Raw한 단계로 설명해보겠습니다.코드 예제: ParentComponent와 ChildComponentfunction ParentComponent() {  const [data, setData] = useState(\"Initial data\");  const updateData = (newData) =&gt; {    setData(newData);  };  return (    &lt;div&gt;      &lt;ChildComponent data={data} updateData={updateData} /&gt;    &lt;/div&gt;  );}function ChildComponent({ data, updateData }) {  return (    &lt;div&gt;      &lt;p&gt;{data}&lt;/p&gt;      &lt;button onClick={() =&gt; updateData(\"Updated data\")}&gt;Update&lt;/button&gt;    &lt;/div&gt;  );}상태 변경과 Reconciliation 과정초기 상태  ParentComponent가 처음 렌더링될 때, data는 \"Initial data\"입니다.  ChildComponent가 처음 렌더링될 때, data는 \"Initial data\"입니다.이때 Virtual DOM 트리는 다음과 같습니다:// ParentComponent의 Virtual DOMReact.createElement(  \"div\",  null,  React.createElement(ChildComponent, {    data: \"Initial data\",    updateData: updateData  }));// ChildComponent의 Virtual DOMReact.createElement(  \"div\",  null,  React.createElement(\"p\", null, \"Initial data\"),  React.createElement(    \"button\",    { onClick: () =&gt; updateData(\"Updated data\") },    \"Update\"  ));상태 업데이트버튼이 클릭되어 updateData('Updated data')가 호출되면, setData가 \"Updated data\"로 상태를 변경합니다. 이때 ParentComponent와 ChildComponent가 다시 호출되며 새로운 Virtual DOM 트리를 생성합니다:// ParentComponent의 새로운 Virtual DOMReact.createElement(  \"div\",  null,  React.createElement(ChildComponent, {    data: \"Updated data\",    updateData: updateData  }));// ChildComponent의 새로운 Virtual DOMReact.createElement(  \"div\",  null,  React.createElement(\"p\", null, \"Updated data\"),  React.createElement(    \"button\",    { onClick: () =&gt; updateData(\"Updated data\") },    \"Update\"  ));Reconciliation리액트는 새로운 Virtual DOM 트리와 이전 Virtual DOM 트리를 비교하여 변경된 부분을 찾아냅니다. 변경된 부분은 &lt;p&gt; 요소의 텍스트 콘텐츠입니다: 'Initial data' → 'Updated data'.Commit Phase리액트는 변경된 부분만 실제 DOM에 반영합니다. 이 경우 &lt;p&gt; 요소의 텍스트 콘텐츠만 업데이트됩니다:// 실제 DOM 업데이트const pElement = document.querySelector(\"p\");pElement.textContent = \"Updated data\";JSX 변환 예제JSX 코드를 React.createElement 함수 호출로 변환하는 예제를 다시 보겠습니다:const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;;// JSX 변환 후 실제 코드const element = React.createElement(\"h1\", null, \"Hello, world!\");마찬가지로, 주어진 컴포넌트 코드도 React.createElement 함수 호출로 변환될 수 있습니다:function ParentComponent() {  const [data, setData] = useState(\"Initial data\");  const updateData = (newData) =&gt; {    setData(newData);  };  return React.createElement(    \"div\",    null,    React.createElement(ChildComponent, { data: data, updateData: updateData })  );}function ChildComponent({ data, updateData }) {  return React.createElement(    \"div\",    null,    React.createElement(\"p\", null, data),    React.createElement(      \"button\",      { onClick: () =&gt; updateData(\"Updated data\") },      \"Update\"    )  );}이렇게 변환된 코드는 Virtual DOM 트리의 구조를 정확히 보여줍니다. 리액트는 이 구조를 기반으로 Reconciliation 과정을 수행하여, 변경된 부분만 실제 DOM에 반영합니다."
  },
  
  {
    "title": "Next.js와 React Server Components (RSC) 이해하기",
    "url": "/posts/Next.js%EC%99%80-React-Server-Components-(RSC)-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/",
    "categories": "Next.js, React",
    "tags": "Next.js, ServerComponents",
    "date": "2024-05-21 00:00:00 +0900",
    





    
    "snippet": "개요Next.js는 React 기반의 프레임워크로, 서버 측 렌더링(SSR), 정적 사이트 생성(SSG) 등의 기능을 통해 React 애플리케이션의 성능을 최적화합니다. Next.js는 React Server Components 개념을 도입하여 서버 컴포넌트와 클라이언트 컴포넌트를 구별합니다. 이러한 기술적 발전과 구분 방법을 다음과 같이 설명하고, ...",
    "content": "개요Next.js는 React 기반의 프레임워크로, 서버 측 렌더링(SSR), 정적 사이트 생성(SSG) 등의 기능을 통해 React 애플리케이션의 성능을 최적화합니다. Next.js는 React Server Components 개념을 도입하여 서버 컴포넌트와 클라이언트 컴포넌트를 구별합니다. 이러한 기술적 발전과 구분 방법을 다음과 같이 설명하고, 이를 최적화하여 활용하는 방법을 소개합니다.기술적인 발전 과정Next.js의 서버 컴포넌트와 클라이언트 컴포넌트 구분은 React의 발전과 밀접한 관련이 있습니다. 초기에는 SSR(Server-Side Rendering)과 CSR(Client-Side Rendering)을 사용했으며, 이후 정적 사이트 생성(SSG), Incremental Static Regeneration(ISR) 등을 도입하여 성능을 최적화해 왔습니다.초기 단계: SSR과 CSRNext.js의 초기 버전에서는 SSR(Server-Side Rendering)과 CSR(Client-Side Rendering)을 주로 사용했습니다. SSR은 서버에서 HTML을 생성하여 클라이언트로 전송하고, CSR은 클라이언트에서 모든 렌더링을 담당합니다.정적 사이트 생성(SSG)Next.js는 이후 정적 사이트 생성(SSG) 기능을 도입하여 빌드 시점에 HTML을 생성하여 CDN에 배포할 수 있게 했습니다. 이를 통해 정적 페이지의 성능을 크게 향상시켰습니다.Incremental Static Regeneration(ISR)Next.js는 Incremental Static Regeneration(ISR)을 도입하여 정적 페이지의 일부만 재생성할 수 있게 했습니다. 이를 통해 페이지 업데이트 시 전체 사이트를 다시 빌드하지 않고 필요한 부분만 갱신할 수 있습니다.React Server ComponentsReact는 React Server Components를 도입하여 서버에서 컴포넌트를 렌더링하고, 클라이언트로 필요한 최소한의 JavaScript만 전송하는 방식을 제안했습니다. Next.js는 이를 빠르게 채택하여 서버 컴포넌트와 클라이언트 컴포넌트를 명확히 구분할 수 있게 했습니다. 이 방식은 서버에서 데이터를 가져오고 처리하여 클라이언트로 전달하는 과정을 단순화합니다.NextJS Server ComponentsNext.js는 getServerSideProps, getStaticProps, getStaticPaths 등의 메서드를 제공하여 서버 사이드에서 데이터를 페칭하고 페이지 컴포넌트로 전달할 수 있게 합니다. 이러한 함수는 특정 페이지 컴포넌트와 연동되어 서버에서 데이터를 미리 가져오고 렌더링하는 과정을 단순화합니다.리액트에서의 Server Components를 SSR로 직접구현기본적으로 리액트는 CSR을 지원하는 ‘라이브러리’이기 떄문에서버컴포넌트를 구성하려면 서버의 구성이 필요합니다1. 기본 서버 사이드 렌더링 설정먼저, Express와 React를 사용하여 서버 사이드 렌더링을 설정합니다.package.json 설치{  \"name\": \"ssr-example\",  \"version\": \"1.0.0\",  \"main\": \"server.js\",  \"scripts\": {    \"start\": \"node server.js\"  },  \"dependencies\": {    \"express\": \"^4.17.1\",    \"react\": \"^17.0.2\",    \"react-dom\": \"^17.0.2\",    \"node-fetch\": \"^2.6.1\",    \"@babel/core\": \"^7.12.3\",    \"@babel/preset-env\": \"^7.12.1\",    \"@babel/preset-react\": \"^7.12.1\",    \"babel-register\": \"^6.26.0\"  }}추가로 바벨 종속성 등록 및 호환성체크server.jsimport express from \"express\";import React from \"react\";import { renderToString } from \"react-dom/server\";import App from \"./src/App\";import fetch from \"node-fetch\";const app = express();app.use(express.static(\"public\"));app.get(\"/\", async (req, res) =&gt; {  const response = await fetch(\"https://api.example.com/data\");  const data = await response.text();  const appHTML = renderToString(&lt;App data={data} /&gt;);  res.send(`    &lt;!DOCTYPE html&gt;    &lt;html&gt;      &lt;head&gt;        &lt;title&gt;SSR Example&lt;/title&gt;      &lt;/head&gt;      &lt;body&gt;        &lt;div id=\"root\"&gt;${appHTML}&lt;/div&gt;        &lt;script&gt;window.__INITIAL_DATA__ = ${JSON.stringify(data).replace(          /&lt;/g,          \"\\\\u003c\"        )}&lt;/script&gt;        &lt;script src=\"/client.js\"&gt;&lt;/script&gt;      &lt;/body&gt;    &lt;/html&gt;  `);});app.listen(3000, () =&gt; {  console.log(\"Server is running on http://localhost:3000\");});Express로 Node서버 구성src/App.jsimport React from \"react\";export default function App() {  return &lt;div&gt;Hello from the server!&lt;/div&gt;;}2. 클라이언트 하이드레이션 설정클라이언트에서 서버에서 전송된 HTML을 하이드레이션합니다.public/client.jsimport React from \"react\";import ReactDOM from \"react-dom\";import App from \"../src/App\";ReactDOM.hydrate(&lt;App /&gt;, document.getElementById(\"root\"));3. 데이터 페칭을 포함한 서버 컴포넌트서버에서 데이터를 페칭하여 렌더링하는 컴포넌트를 추가해보겠습니다.src/App.js (데이터 페칭 추가)import React from \"react\";export default function App({ data }) {  return (    &lt;div&gt;      &lt;h1&gt;Data from server:&lt;/h1&gt;      &lt;p&gt;{data}&lt;/p&gt;    &lt;/div&gt;  );}server.js (데이터 페칭 추가)const express = require(\"express\");const React = require(\"react\");const { renderToString } = require(\"react-dom/server\");const App = require(\"./src/App\").default;const fetch = require(\"node-fetch\");const app = express();app.use(express.static(\"public\"));app.get(\"/\", async (req, res) =&gt; {  const response = await fetch(\"https://api.example.com/data\");  const data = await response.text();  const appHTML = renderToString(&lt;App data={data} /&gt;);  res.send(`    &lt;!DOCTYPE html&gt;    &lt;html&gt;      &lt;head&gt;        &lt;title&gt;SSR Example&lt;/title&gt;      &lt;/head&gt;      &lt;body&gt;        &lt;div id=\"root\"&gt;${appHTML}&lt;/div&gt;        &lt;script&gt;window.__INITIAL_DATA__ = ${JSON.stringify(data)}&lt;/script&gt;        &lt;script src=\"/client.js\"&gt;&lt;/script&gt;      &lt;/body&gt;    &lt;/html&gt;  `);});app.listen(3000, () =&gt; {  console.log(\"Server is running on http://localhost:3000\");});public/client.js (하이드레이션 수정)import React from \"react\";import ReactDOM from \"react-dom\";import App from \"../src/App\";const data = window.__INITIAL_DATA__;ReactDOM.hydrate(&lt;App data={data} /&gt;, document.getElementById(\"root\"));4.최적화: 코드 스플리팅 및 React.lazyReact.lazy와 Suspense를 사용하여 코드 스플리팅으로 최적화합니다.src/App.js (코드 스플리팅 추가)import React, { Suspense } from \"react\";const DataComponent = React.lazy(() =&gt; import(\"./DataComponent\"));export default function App({ data }) {  return (    &lt;div&gt;      &lt;h1&gt;Data from server:&lt;/h1&gt;      &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;        &lt;DataComponent data={data} /&gt;      &lt;/Suspense&gt;    &lt;/div&gt;  );}src/DataComponent.jsimport React from \"react\";export default function DataComponent({ data }) {  return &lt;p&gt;{data}&lt;/p&gt;;}5. 최적화: 서버 사이드 데이터 로딩서버에서 데이터를 미리 로딩하고 클라이언트로 전달하여 네트워크 요청을 최소화합니다.server.js (서버 사이드 데이터 로딩 추가)const express = require(\"express\");const React = require(\"react\");const { renderToString } = require(\"react-dom/server\");const App = require(\"./src/App\").default;const fetch = require(\"node-fetch\");const app = express();app.use(express.static(\"public\"));app.get(\"/\", async (req, res) =&gt; {  const response = await fetch(\"https://api.example.com/data\");  const data = await response.text();  const appHTML = renderToString(&lt;App data={data} /&gt;);  res.send(`    &lt;!DOCTYPE html&gt;    &lt;html&gt;      &lt;head&gt;        &lt;title&gt;SSR Example&lt;/title&gt;      &lt;/head&gt;      &lt;body&gt;        &lt;div id=\"root\"&gt;${appHTML}&lt;/div&gt;        &lt;script&gt;window.__INITIAL_DATA__ = ${JSON.stringify(data)}&lt;/script&gt;        &lt;script src=\"/client.js\"&gt;&lt;/script&gt;      &lt;/body&gt;    &lt;/html&gt;  `);});app.listen(3000, () =&gt; {  console.log(\"Server is running on http://localhost:3000\");});React에서 React Server Components (RSC) 구현 패턴React에서 RSC를 직접 구현하려면 다음과 같은 과정이 필요합니다:  서버 컴포넌트 작성: 서버에서 렌더링할 컴포넌트를 작성합니다.  서버 설정: Express 또는 Koa 같은 Node.js 서버를 설정하여 서버 컴포넌트를 렌더링합니다.  데이터 페칭 및 렌더링: 서버 컴포넌트에서 필요한 데이터를 페칭하고 HTML로 렌더링합니다.  클라이언트 전송: 렌더링된 HTML과 필요한 데이터만 클라이언트로 전송합니다.  클라이언트 하이드레이션: 클라이언트에서 받은 HTML을 하이드레이션하여 상호작용을 추가합니다.NextJS에서의 Server Components 구현 방법Next.js는 페이지 수준에서 데이터 페칭 및 서버 사이드 렌더링을 지원합니다. getServerSideProps 함수를 사용하여 서버 측에서 데이터를 페칭할 수 있습니다.사용 시 주의사항  데이터 페칭: 서버 컴포넌트에서만 데이터 페칭을 수행하고, 클라이언트 컴포넌트에서는 데이터 페칭을 피하는 것이 좋습니다. 이는 서버에서 데이터를 가져오는 것이 더 효율적이기 때문입니다.  상태 관리: 클라이언트 컴포넌트에서는 상태 관리를 사용하여 사용자와의 상호작용을 처리합니다. 서버 컴포넌트에서는 상태 관리를 사용하지 않습니다.  보안: 서버 컴포넌트에서는 클라이언트로 전송되기 전에 모든 데이터가 서버에서 렌더링되므로 보안상 이점이 있습니다.// app/serverComponent.server.jsimport fetchData from 'path/to/fetchData';export default function ServerComponent() {  const data = fetchData();  return (    &lt;div&gt;      &lt;h1&gt;Server Component&lt;/h1&gt;      &lt;p&gt;Data: {data}&lt;/p&gt;    &lt;/div&gt;  );}// app/clientComponent.client.js\"use client\";import { useState } from 'react';export default function ClientComponent() {  const [count, setCount] = useState(0);  return (    &lt;div&gt;      &lt;h1&gt;Client Component&lt;/h1&gt;      &lt;p&gt;Count: {count}&lt;/p&gt;      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;    &lt;/div&gt;  );}React Server Components (RSC)와 Next.js에서의 구현 차이점  설정과 구성:          React: 서버 설정(예: Express, Koa)을 직접 구성해야 하며, 데이터 페칭과 렌더링을 직접 처리합니다.      Next.js: 파일 시스템 기반 라우팅과 자동 설정을 통해 구성 작업을 최소화하며, 서버 컴포넌트와 클라이언트 컴포넌트를 쉽게 구분하고 사용할 수 있습니다.        데이터 페칭과 렌더링:          React: 데이터 페칭과 렌더링 로직을 직접 작성해야 하며, 서버와 클라이언트 간의 데이터 전송을 직접 관리해야 합니다.      Next.js: getServerSideProps와 getStaticProps 같은 메서드를 사용하여 데이터 페칭과 렌더링을 자동으로 처리하며, 클라이언트로 전송되는 데이터를 최적화합니다.        자동 최적화:          React: 모든 최적화 작업을 직접 수행해야 합니다.      Next.js: 자동 최적화를 통해 서버에서 렌더링된 결과와 클라이언트 측 상호작용을 최적화합니다.            개발 편의성:          React: 초기 설정과 구성이 복잡하며, 모든 작업을 직접 관리해야 합니다.      Next.js: 설정과 구성이 간편하며, 서버 컴포넌트와 클라이언트 컴포넌트를 쉽게 구분하고 사용할 수 있어 개발 편의성이 높습니다.리액트의 복잡한 설정이 필요없어지니 확실히 프레임워크는 프레임워크입니다.다음은 NextJS에서의 활용방법들입니다.        Next.js에서의 활용    1. 컴포넌트 구분 명확히 하기    서버 컴포넌트와 클라이언트 컴포넌트를 명확히 구분하는 것은 중요합니다. 파일 네이밍과 디렉토리 구조를 통해 이를 명확히 하는 것이 좋습니다.    - components/  - ServerComponent.server.js  - ClientComponent.client.js        서버 컴포넌트는 서버에서만 렌더링되므로 보안에 민감한 데이터를 처리할 수 있으며, 클라이언트 컴포넌트는 사용자 인터랙션을 담당합니다.    2. 데이터 페칭과 상태 관리 최적화    서버 컴포넌트에서 데이터 페칭    서버 컴포넌트에서 데이터를 페칭하는 것이 성능 면에서 유리합니다. getServerSideProps 또는 getStaticProps를 사용하여 데이터를 서버에서 미리 로드합니다.    // components/ServerComponent.server.jsimport fetchData from \"path/to/fetchData\";export default function ServerComponent() {  const data = fetchData();  return (    &lt;div&gt;      &lt;h1&gt;Server Component&lt;/h1&gt;      &lt;p&gt;Data: {data}&lt;/p&gt;    &lt;/div&gt;  );}        클라이언트 컴포넌트에서 상태 관리    클라이언트 컴포넌트에서는 상태 관리 라이브러리(예: Redux, Zustand)를 사용하여 사용자 인터랙션을 처리합니다.    // components/ClientComponent.client.js\"use client\";import { useState } from \"react\";export default function ClientComponent() {  const [count, setCount] = useState(0);  return (    &lt;div&gt;      &lt;h1&gt;Client Component&lt;/h1&gt;      &lt;p&gt;Count: {count}&lt;/p&gt;      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;    &lt;/div&gt;  );}        하이드레이션 문제의 최적화 전후 코드 비교    문제: 하이드레이션 최적화    서버에서 렌더링된 HTML을 클라이언트에서 하이드레이션할 때 발생하는 성능 문제와 일관성 문제를 해결해야 했습니다. 특히, 초기 로드 시 느린 하이드레이션 속도는 사용자 경험을 저하시킬 수 있습니다.    문제 발생 전 코드    ServerComponent.server.js    export default function ServerComponent() {  return (    &lt;div&gt;      &lt;h1&gt;Server Component&lt;/h1&gt;      &lt;p&gt;Data: Static data&lt;/p&gt;    &lt;/div&gt;  );}        ClientComponent.client.js    \"use client\";import { useState, useEffect } from \"react\";export default function ClientComponent() {  const [data, setData] = useState(null);  useEffect(() =&gt; {    fetch(\"/api/data\")      .then((response) =&gt; response.json())      .then((data) =&gt; setData(data));  }, []);  return (    &lt;div&gt;      &lt;h1&gt;Client Component&lt;/h1&gt;      &lt;p&gt;Data: {data}&lt;/p&gt;    &lt;/div&gt;  );}        이 코드는 서버에서 렌더링된 후 클라이언트에서 데이터를 다시 페칭합니다. 이는 불필요한 네트워크 요청을 초래하고, 하이드레이션 속도를 저하시킵니다.    문제 해결 후 코드    ServerComponent.server.js    import fetchData from \"path/to/fetchData\";export default function ServerComponent({ initialData }) {  return (    &lt;div&gt;      &lt;h1&gt;Server Component&lt;/h1&gt;      &lt;p&gt;Data: {initialData}&lt;/p&gt;    &lt;/div&gt;  );}// getServerSideProps.jsexport async function getServerSideProps() {  const data = await fetchData();  return { props: { initialData: data } };}        ClientComponent.client.js    \"use client\";import { useState } from \"react\";export default function ClientComponent({ initialData }) {  const [data] = useState(initialData);  return (    &lt;div&gt;      &lt;h1&gt;Client Component&lt;/h1&gt;      &lt;p&gt;Data: {data}&lt;/p&gt;    &lt;/div&gt;  );}        이 코드는 서버에서 데이터를 미리 페칭하고 클라이언트로 전달합니다. 이렇게 하면 클라이언트에서 추가적인 네트워크 요청 없이 하이드레이션이 이루어져 초기 로드 속도가 개선됩니다. 또한, React의 상태 관리를 사용하여 초기 데이터를 설정하므로 데이터 일관성 문제가 해결됩니다.    3. 코드 스플리팅과 동적 임포트 사용    큰 애플리케이션에서는 성능 최적화를 위해 코드 스플리팅과 동적 임포트를 사용하는 것이 중요합니다. 이를 통해 초기 로드 시간을 줄이고 필요한 부분만 로드할 수 있습니다.    // components/ClientComponent.client.jsimport dynamic from \"next/dynamic\";const HeavyComponent = dynamic(() =&gt; import(\"./HeavyComponent.client\"), {  ssr: false,  loading: () =&gt; &lt;p&gt;Loading...&lt;/p&gt;});export default function ClientComponent() {  return (    &lt;div&gt;      &lt;h1&gt;Client Component&lt;/h1&gt;      &lt;HeavyComponent /&gt;    &lt;/div&gt;  );}        결론    이번 포스팅은 직접 React로 NextJS의 SSR 기능을 모방하고 , 이를 NextJS 에서는 어떻게 활용하는지 포스팅하였습니다다음 포스팅은 Vercel팀이 어떻게 nextJS에 서버컴포넌트를 구현했는지 오픈소스를 까서보는 시간이 될것같습니다.  "
  },
  
  {
    "title": "AWS Docker 컨테이너의 MariaDB 데이터베이스 덤프 파일 생성 및 복사",
    "url": "/posts/AWS-Docker-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EC%9D%98-MariaDB-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EB%8D%A4%ED%94%84-%ED%8C%8C%EC%9D%BC-%EC%83%9D%EC%84%B1-%EB%B0%8F-%EB%B3%B5%EC%82%AC/",
    "categories": "AWS, Docker, MariaDB, Backup",
    "tags": "",
    "date": "2024-05-21 00:00:00 +0900",
    





    
    "snippet": "AWS Docker 컨테이너의 MariaDB 데이터베이스 덤프 파일 생성 및 복사개요이 블로그 글에서는 AWS 인스턴스의 Docker 컨테이너에서 MariaDB 데이터베이스 덤프 파일을 생성하고,이를 호스트 로컬 폴더로 복사하는 방법을 단계별로 설명합니다.현재 나의 상황은 AWS 인스턴스로 올라가있는 서버와해당 서버가 이용중인 DB가 도커환경에서 구동...",
    "content": "AWS Docker 컨테이너의 MariaDB 데이터베이스 덤프 파일 생성 및 복사개요이 블로그 글에서는 AWS 인스턴스의 Docker 컨테이너에서 MariaDB 데이터베이스 덤프 파일을 생성하고,이를 호스트 로컬 폴더로 복사하는 방법을 단계별로 설명합니다.현재 나의 상황은 AWS 인스턴스로 올라가있는 서버와해당 서버가 이용중인 DB가 도커환경에서 구동중입니다SSH로 공유된 원격 인스턴스에 접근하여 인스턴스 내부에서 돌아가는 DB환경을 로컬로 재구성하기위해서 필요한 작업을 합니다.1. Docker 컨테이너 내부에서 MariaDB 덤프 파일 생성먼저 Docker 컨테이너 내부에 접속하여 MariaDB 데이터베이스 덤프 파일을 생성합니다.컨테이너 이름을 사용하는 방법:sudo docker exec -it [container_name] /bin/bash컨테이너 ID를 사용하는 방법:sudo docker exec -it [container_id] /bin/bash컨테이너 내부에서 mysqldump 명령어를 실행하여 덤프 파일을 생성합니다:mysqldump  -uroot -p [password] [database] &gt; /tmp/[dumpFileName].sql열 통계 정보 포함 비활성화:MySQL 8.0.21부터 mysqldump는 기본적으로 열 통계 정보를 덤프 파일에 포함시킵니다. 그러나 일부 MariaDB 버전 또는 특정 설정에서는 이 기능이 호환되지 않을 수 있습니다. 따라서 이 옵션을 사용하면 열 통계 정보를 포함하지 않도록 설정할 수 있습니다.만약 mariaDB를 사용하는 환경이고 , 아래와같은 에러가 발생한다면 열통계를 끄는 옵션을 추가하여주세요mysqldump: Couldn't execute 'SELECT COLUMN_NAME,JSON_EXTRACT(HISTOGRAM, '$.\"number-of-buckets-specified\"')FROM information_schema.COLUMN_STATISTICSWHERE SCHEMA_NAME = '[DatabaseName]'AND TABLE_NAME = '[TableName]';':Unknown table 'COLUMN_STATISTICS' in information_schema (1109)이 오류는 MariaDB와 MySQL 버전 차이로 인해 발생하며 mysqldump 명령어가 information_schema 데이터베이스의 COLUMN_STATISTICS 테이블을 찾지 못해서 발생합니다.현재 우리의 DB구성은 mariaDB였기에 버전호환성 문제를 일으키는 것 같습니다.이를 해결하기 위해 –column-statistics=0 옵션을 추가하여 COLUMN_STATISTICS 기능을 비활성화할 수 있습니다.mysqldump --column-statistics=0 -uroot -p [password] [database] &gt; /tmp/[dumpFileName].sql2. 덤프 파일 존재 확인컨테이너 내부에서 덤프 파일이 잘 생성되었는지 확인합니다:ls -al /tmp/예상 출력 예시:root@[container_id]:/# ls -al /tmp/total 12drwxrwxrwt  2 root root 4096 May 21 12:00 .drwxr-xr-x 21 root root 4096 May 21 12:00 ..-rw-r--r--  1 root root 2048 May 21 12:00 [dumpedFileName].sql3.컨테이너에서 호스트로 덤프 파일 복사덤프파일이 생성된 컨테이너의 임시볼륨에 접근하고 SQL파일을 특정경로로 복사해줍니다sudo docker cp [container_id or container_name]:/tmp/[dumpedFileName].sql /home/ubuntu/[copyFileName].sql또는 현재 디렉토리에 복사하려면 다음과 같이 합니다:sudo docker cp 615ff7727e34:/tmp/backup0521.sql .요약이 과정을 통해 AWS 인스턴스의 Docker 컨테이너에서 MariaDB 데이터베이스 덤프 파일을 생성하고이를 호스트 머신으로 복사할 수 있습니다  Docker 컨테이너 내부에 접속  mysqldump 명령어를 사용하여 덤프 파일 생성  ls -al 명령어로 덤프 파일 존재 확인  docker cp 명령어로 덤프 파일을 호스트로 복사"
  },
  
  {
    "title": "Docker 이해하기:arm환경에서 Docker로 python서버 구성하기",
    "url": "/posts/Docker-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-arm%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-Docker%EB%A1%9C-python%EC%84%9C%EB%B2%84-%EA%B5%AC%EC%84%B1%ED%95%98%EA%B8%B0/",
    "categories": "docker",
    "tags": "docker",
    "date": "2024-05-15 00:00:00 +0900",
    





    
    "snippet": "Docker 소개Docker는 개발자들이 어디에서나 일관된 환경에서 애플리케이션을 실행할 수 있도록 컨테이너라는 형태로 소프트웨어를 패키징할 수 있는 플랫폼으로, 소프트웨어 개발에 혁명을 일으켰습니다. 이 글에서는 Docker가 등장한 배경, 그리고 컨테이너, 이미지, 볼륨, 빌드 프로세스 같은 주요 개념을 탐구하고, 이러한 개념들이 어떻게 효율적이고...",
    "content": "Docker 소개Docker는 개발자들이 어디에서나 일관된 환경에서 애플리케이션을 실행할 수 있도록 컨테이너라는 형태로 소프트웨어를 패키징할 수 있는 플랫폼으로, 소프트웨어 개발에 혁명을 일으켰습니다. 이 글에서는 Docker가 등장한 배경, 그리고 컨테이너, 이미지, 볼륨, 빌드 프로세스 같은 주요 개념을 탐구하고, 이러한 개념들이 어떻게 효율적이고 예측 가능한 소프트웨어 배포에 기여하는지 살펴보고 , ARM아키텍쳐로 구성된 로컬환경에서버전이 낮은 Python서버를 Docker로 구성하고 서버를 돌려봅니다..Docker의 등장Docker는 2013년에 도입되어, 서로 다른 컴퓨팅 환경에서 소프트웨어를 신뢰성 있게 구성하는 복잡성에 대응하였습니다. 컨테이너 기술을 활용하여 기반 인프라에 관계없이 코드가 동일하게 실행될 수 있도록 함으로써 개발, 테스트 및 배포 워크플로우를 단순화했습니다.주요 Docker 개념 이해컨테이너컨테이너는 코드, 런타임, 라이브러리 및 시스템 설정을 포함하여 애플리케이션 실행에 필요한 모든 것이 포함된 경량의 실행 가능한 패키지입니다. Docker 이미지를 기반으로 운영되며, 각 컨테이너는 서로 완전히 격리되어 있어 같은 호스트에서 실행되어도 서로 영향을 주지 않습니다. 컨테이너는 일시적인 상태를 가지며 실행 중일 때만 상태가 유지됩니다.이미지이미지는 컨테이너 실행에 필요한 파일과 설정이 포함된 불변의 스냅샷입니다. 컨테이너를 생성하는 데 사용되는 템플릿으로 생각할 수 있으며, 하나의 이미지에서 여러 컨테이너를 생성할 수 있습니다. 이미지는 대개 Dockerfile이라는 텍스트 문서를 통해 생성되며, 이 문서에는 컨테이너를 어떻게 구성할지에 대한 지시사항이 포함되어 있습니다.볼륨볼륨은 데이터를 컨테이너와 독립적으로 저장하고 관리할 수 있는 메커니즘입니다. 컨테이너는 일반적으로 불변하며 상태가 없지만, 볼륨을 사용하면 데이터를 영구적으로 저장하거나 여러 컨테이너 간에 공유할 수 있습니다. 볼륨은 호스트 시스템의 특정 부분에 데이터를 저장하며, 컨테이너가 삭제되어도 데이터는 유지됩니다.빌드 프로세스빌드 프로세스는 소스 코드로부터 Docker 이미지를 생성하는 과정입니다. Dockerfile에 정의된 지시사항을 순차적으로 실행하여 이미지의 새로운 계층을 추가하며, 이 계층들이 최종 이미지를 구성합니다. 이렇게 생성된 이미지는 재사용이 가능하며 다른 시스템에 쉽게 배포할 수 있습니다.Docker 이미지 준비이제 기본적인 도커의 개념에 대해 학습했다 믿고 python서버를 docker위에서 구동되는 방법에 대해 소개합니다.Docker를 사용하여 호환성 문제를 해결할 수 있는 Python 3.10 이미지를 준비합니다. Dockerfile을 작성하여 필요한 설정을 구성할 수 있습니다.Python 3.10 이미지를 기반으로 설정FROM python:3.10작업 디렉토리 설정WORKDIR /app의존성 파일 복사COPY requirements.txt .의존성 설치requirements.txt에는 사용중인 라이브러리의 의존성들이 담겨져 있습니다.RUN pip install -r requirements.txt애플리케이션 코드 복사COPY . .서버 실행CMD [\"python\", \"app.py\"]도커 이미지 빌드docker build -t my-python-app .도커 컨테이너실행docker run -p 7077:7077 my-python-app포트번호는 각자 REST API통신을 하기위해 합의된 번호를 사용합니다.도커 컨테이너가 잘 실행되는지 확인하기위해서 REST API를 날려보고 WireShark로 원활한 통신을 하는지 확인해 봅니다서버에서 미리 정의해둔 비지니스 로직을 실행하고 반환하는 값이 정상적입니다.위의 방식으로 7077 포트를 사용하는 파이썬 서버를 도커환경에서 구성하고 API를 실행시켜보았습니다.이로써 어떤 상황에도 서버를 원활하게 구동할 준비가 되었습니다!"
  },
  
  {
    "title": "Electron에서 alert 사용시 input 읽기 전용 문제 해결",
    "url": "/posts/Electron%EC%97%90%EC%84%9C%EC%9D%98-input%EC%9D%B4-%EC%9D%98%EB%8F%84%EC%B9%98%EC%95%8A%EA%B2%8C-readonly%EB%A1%9C-%EA%B0%95%EC%A0%9C%EB%90%98%EB%8A%94-%ED%98%84%EC%83%81/",
    "categories": "Electron, troubleshooting",
    "tags": "",
    "date": "2024-05-13 00:00:00 +0900",
    





    
    "snippet": "개요Electron 애플리케이션에서 alert() 함수를 사용할 때, input 태그가 읽기 전용으로 설정되는 현상이 종종 발생합니다. 이 현상은 Electron의 구조적 특성 때문에 나타나는 문제로, 이해를 돕기 위해 문제의 원인과 해결 방안을 상세히 설명하겠습니다.원인 분석Electron은 Chromium과 Node.js를 기반으로 하는데, 이는 ...",
    "content": "개요Electron 애플리케이션에서 alert() 함수를 사용할 때, input 태그가 읽기 전용으로 설정되는 현상이 종종 발생합니다. 이 현상은 Electron의 구조적 특성 때문에 나타나는 문제로, 이해를 돕기 위해 문제의 원인과 해결 방안을 상세히 설명하겠습니다.원인 분석Electron은 Chromium과 Node.js를 기반으로 하는데, 이는 Electron이 브라우저와 유사한 환경을 제공하지만, 일부 특성이 다르다는 것을 의미합니다. 일반적인 웹 브라우저에서는 alert(), prompt(), confirm() 같은 함수들이 동기적으로 실행되어, 사용자의 입력을 기다리는 동안 전체 렌더링 엔진을 멈춥니다. 그러나 Electron에서는 이러한 함수들이 메인 프로세스의 시스템 대화 상자를 통해 실행되며, 이 과정에서 렌더러 프로세스는 계속해서 비동기적으로 동작합니다.이 때문에, 메인 스레드가 시스템 모달을 실행하면서 렌더러 프로세스의 입력 필드 등이 일시적으로 읽기 전용 상태가 될 수 있습니다. 이는 메인 프로세스와 렌더러 프로세스가 독립적으로 작동하면서 발생하는 동기화 문제로 볼 수 있습니다.해결 방안비동기 대화 상자 사용하기Electron의 dialog 모듈을 사용하여 비동기적으로 메시지 박스를 표시할 수 있습니다. 이 방법은 렌더러 프로세스를 차단하지 않고 사용자의 입력을 받을 수 있습니다.const { dialog } = require(\"electron\");dialog  .showMessageBox({    type: \"info\",    title: \"Information\",    message: \"This is an important message.\"  })  .then((result) =&gt; {    console.log(result.response);  });사용자 정의 모달 구현하기HTML과 CSS를 활용하여 사용자 정의 모달을 만들어 사용하는 것도 좋은 방법입니다. 이는 UI/UX를 완전히 제어할 수 있으며, 기존의 웹 기술을 활용하므로 개발자에게 친숙합니다.&lt;div id=\"myModal\" class=\"modal\"&gt;  &lt;div class=\"modal-content\"&gt;    &lt;span class=\"close\"&gt;&amp;times;&lt;/span&gt;    &lt;p&gt;Some text in the Modal..&lt;/p&gt;  &lt;/div&gt;&lt;/div&gt;&lt;style&gt;.modal {    display: none;    position: fixed;    z-index: 1;    left: 0;    top: 0;    width: 100%;    height: 100%;    overflow: auto;    background-color: rgb(0,0,0);    background-color: rgba(0,0,0,0.4);}&lt;/style&gt;const modal = document.getElementById(\"myModal\");const span = document.getElementsByClassName(\"close\")[0];span.onclick = function() {    modal.style.display = \"none\";}window.onclick = function(event) {    if (event.target == modal) {        modal.style.display = \"none\";    }}결론Electron에서 alert() 함수의 사용은 입력 필드를 일시적으로 읽기 전용으로 만들 수 있습니다. 이 문제를 해결하기 위해 비동기 대화 상자 사용이나 사용자 정의 모달 구현을 추천합니다. 이 방법들을 통해 사용자 경험을 개선하고 애플리케이션의 효율성을 높일 수 있습니다.커스텀 alert나 modal, dialog 사용함으로써 Electron의 에러를 회피해야합니다. 처음 이 에러를 접하면 어떠한 동작때문인가 싶을텐데해당 이벤트(클릭,handler함수 실행의 사이드이페트)보단 alert그 자체의 문제였어서 당황하였습니다."
  },
  
  {
    "title": "Stencil에서 정적 파일을 이용한 SEO 최적화: RSS, Sitemap, Robots.txt 설정하기",
    "url": "/posts/stencil%EC%97%90%EC%84%9C-%EC%A0%95%EC%A0%81%ED%8C%8C%EC%9D%BC-%EC%B6%94%EA%B0%80%ED%95%B4-SEO%EC%B5%9C%EC%A0%81%ED%99%94%ED%95%98%EA%B8%B0/",
    "categories": "web-development, seo, stencil, vercel, deploy",
    "tags": "",
    "date": "2024-05-12 00:00:00 +0900",
    





    
    "snippet": "개요이 포스트에서는 Stencil 프로젝트에서 SEO를 향상시키기 위해 RSS, sitemap, 및 robots.txt 파일을 정적 파일로 추가하고, 이를 Vercel을 통해 배포하는 과정을 소개하려고 합니다.배경웹 개발에서 검색 엔진 최적화(SEO)는 매우 중요합니다. 효과적인 SEO 설정을 통해 검색 엔진에서 더 높은 순위를 얻고, 이로 인해 웹사...",
    "content": "개요이 포스트에서는 Stencil 프로젝트에서 SEO를 향상시키기 위해 RSS, sitemap, 및 robots.txt 파일을 정적 파일로 추가하고, 이를 Vercel을 통해 배포하는 과정을 소개하려고 합니다.배경웹 개발에서 검색 엔진 최적화(SEO)는 매우 중요합니다. 효과적인 SEO 설정을 통해 검색 엔진에서 더 높은 순위를 얻고, 이로 인해 웹사이트의 트래픽과 가시성이 증가할 수 있습니다.Stencil 프로젝트 설정Stencil은 웹 컴포넌트를 빌드하기 위한 도구이며, 다음과 같이 프로젝트를 설정합니다.  assets 디렉토리에 SEO 관련 파일을 저장합니다.  기본적으로 stencil읭 빌드 경로 www/assets/ 파일들이 해당 위치에 저장됩니다.  SEO폴더안의 정적, 혹은 동적으로 생성된 SEO 파일들을 vercel.json으로 라우팅처리를 해줍니다.파일 구조/www/assets/SEO/└──sitemap.xml└──rss.xml├── rss.xmlVercel에서의 배포Vercel을 사용하여 Stencil 프로젝트를 배포하는 과정은 다음과 같습니다.설정 파일 (vercel.json){  \"rewrites\": [    { \"source\": \"/sitemap.xml\", \"destination\": \"/assets/SEO/sitemap.xml\" },    { \"source\": \"/rss.xml\", \"destination\": \"/assets/SEO/rss.xml\" },    { \"source\": \"/robots.txt\", \"destination\": \"/assets/SEO/robots.txt\" }  ],  \"headers\": [    {      \"source\": \"/rss.xml\",      \"headers\": [        {          \"key\": \"Content-Type\",          \"value\": \"application/xml; charset=utf-8\"        }      ]    },    {      \"source\": \"/sitemap.xml\",      \"headers\": [        {          \"key\": \"Content-Type\",          \"value\": \"application/xml; charset=utf-8\"        }      ]    },    {      \"source\": \"/robots.txt\",      \"headers\": [        {          \"key\": \"Content-Type\",          \"value\": \"text/plain; charset=utf-8\"        },        {          \"key\": \"Cache-Control\",          \"value\": \"public, max-age=86400\"        }      ]    }  ]}라우팅과 파일 타입 설정위의 vercel.json 설정을 통해 각 파일에 적절한 Content-Type 헤더를 설정하고, 캐시 제어를 위한 Cache-Control 헤더를 추가하여 SEO를 최적화할 수 있습니다.마치며이 글에서는 Stencil과 Vercel을 사용하여 RSS, sitemap, 및 robots.txt 파일을 관리하고 SEO를 개선하는 방법을 알아보았습니다.사실은 위의 SEO적용에서의 시행착오가 많았습니다.프로젝트 루트에 해당파일을 위치시켜서 빌드하면 정적자산들이 제대로 빌드되지않는 현상을 겪었고,stencil에서의 정적자산들에 대한 기본위치는 리액트에서의 public처럼 assets에 위치해 있다는 사실을 파악하고vercel에서의 빌드설정파일인 vercel.json에서 최종적으로 자산에 대한 설정을 추가적으로 작업해줘야했습니다결론적으로 deploy되는 폴더인 www/assets/설정 및 저장한 폴더의 정적자산 PATH로 설정을 해줘야합니다..이 설정은 정적자산을 바탕으로 포스팅되었지만 해당 정적자산들을 동적으로 바꿔준다 하더라도 유효합니다."
  },
  
  {
    "title": "일렉트론에서의 서버 오류 핸들링",
    "url": "/posts/%EC%9D%BC%EB%A0%89%ED%8A%B8%EB%A1%A0%EC%97%90%EC%84%9C%EC%9D%98-%EC%84%9C%EB%B2%84-%ED%97%AC%EC%8A%A4%EC%B2%B4%ED%81%AC/",
    "categories": "Electron, Node.js, Socket Server",
    "tags": "Health Check, Server Handling, Socket Server, Electron, troubleshooting",
    "date": "2024-05-10 00:00:00 +0900",
    





    
    "snippet": "개요데이터베이스 백업 로직 중 DB에 센서의 신호값을 저장하거나 , 갖가지 정보 등의 데이터를 소켓 서버에서 참조하는 과정에서 데이터의 무결성을 잃는 현상이 발생했습니다.이로 인해 소켓 서버가 에러를 일으켜 실행되지 않는 오류가 발생했습니다.첫번째는 백업로직중 , 관련된 서버의 동작을 일시정지하는것이 우선되어야겠지만 저는 어느상황에서든지 서버의 이상을...",
    "content": "개요데이터베이스 백업 로직 중 DB에 센서의 신호값을 저장하거나 , 갖가지 정보 등의 데이터를 소켓 서버에서 참조하는 과정에서 데이터의 무결성을 잃는 현상이 발생했습니다.이로 인해 소켓 서버가 에러를 일으켜 실행되지 않는 오류가 발생했습니다.첫번째는 백업로직중 , 관련된 서버의 동작을 일시정지하는것이 우선되어야겠지만 저는 어느상황에서든지 서버의 이상을 감지하고 서버가 자동으로 재실행되는 항상성을 유지하고싶었습니다.따라서 헬스체크의 필요성을 느끼고 일렉트론에서 특정 주기마다 헬스체크를 진행하여 의도치 않은 모든 오류를 핸들링하는 로직을 구현했습니다.추후에 DB백업로직이 실행되면 관련로직의 Socket을 끊고 재연결하고, DB 저장을 일시정지하는 로직을 추가개발해야합니다.헬스체크 로직시스템 환경마다 서버의 실행시간을 예측하기란 어려운 일입니다. 프로그램이 요구하는 시스템의 최소사양에서의 서버실행시간의 평균값인 3초보다 여유를 둔 5초 단위로서비스가 실행되면 헬스체크 메세지를 날리고 , 해당메세지의 respanse Message가 돌아오지못한다면(서버가 원활하지못한다면) 서버를 재실행합니다.재실행은 5초에서 10초 , 20초 , 40초 최대 1분간 기다리며 , 모든 재실행이 실패한다면 dialog로 사용자에게 서버가 원활하지않음을 알립니다.일렉트론 파일에서의 헬스체크 로직// electron 파일에서의 헬스체크 로직let consecutiveFailures = 0;const INITIAL_INTERVAL = 5000;const MAX_INTERVAL = 60000; // 최대 재시작 간격 (60초)let currentInterval = INITIAL_INTERVAL;async function socketHealthCheck() {  if (socketProcess) {    socketProcess.send(\"check-health\");    const isHealthy = await new Promise((resolve) =&gt; {      const timer = setTimeout(() =&gt; {        resolve(false);      }, 5000);      socketProcess.once(\"message\", (message) =&gt; {        if (message === \"socket server health!\") {          clearTimeout(timer);          resolve(true);          console.log(\"socket OK!!\");        }      });    });    if (!isHealthy) {      console.log(\"Socket server is unhealthy, restart\");      await restartSocketServer();      consecutiveFailures += 1;      currentInterval = Math.min(currentInterval * 2, MAX_INTERVAL); // 간격을 두 배로 늘립니다.      mainWindow.reload();      // 연속 실패가 최대 허용 횟수를 초과하면 경고 대화상자를 표시합니다.      if (consecutiveFailures &gt;= MAX_CONSECUTIVE_FAILURES) {        dialog.showMessageBox({          type: \"warning\",          title: \"Socket Server Warning\",          message:            \"소켓 서버가 건강하지 않습니다. 문제가 지속되면 시스템 관리자에게 문의하세요.\",          buttons: [\"확인\"]        });      }    } else {      consecutiveFailures = 0;      currentInterval = INITIAL_INTERVAL; // 서버가 건강하면 간격을 초기화합니다.    }  }}async function restartSocketServer() {  if (socketProcess) {    socketProcess.kill();    socketProcess = null;    await socketStart();    console.log(\"Socket server restarted\");  }}// 일정 간격으로 소켓 서버의 건강을 확인하고, 실패할 경우 간격을 조정합니다.function scheduleHealthCheck() {  setTimeout(() =&gt; {    socketHealthCheck().then(() =&gt; {      scheduleHealthCheck(); // 다음 건강 점검을 스케줄링합니다.    });  }, currentInterval);}scheduleHealthCheck(); // 건강 점검을 시작합니다."
  }
  
]

