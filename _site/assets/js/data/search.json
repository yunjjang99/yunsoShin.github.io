[
  
  {
    "title": "Stencil에서 정적 파일을 이용한 SEO 최적화: RSS, Sitemap, Robots.txt 설정하기",
    "url": "/posts/stencil%EC%97%90%EC%84%9C-%EC%A0%95%EC%A0%81%ED%8C%8C%EC%9D%BC-%EC%B6%94%EA%B0%80%ED%95%B4-SEO%EC%B5%9C%EC%A0%81%ED%99%94%ED%95%98%EA%B8%B0/",
    "categories": "web-development, seo, stencil, vercel",
    "tags": "",
    "date": "2024-05-12 00:00:00 +0800",
    





    
    "snippet": "도입부이 포스트에서는 Stencil 프로젝트에서 SEO를 향상시키기 위해 RSS, sitemap, 및 robots.txt 파일을 정적 파일로 추가하고, 이를 Vercel을 통해 배포하는 과정을 소개하려고 합니다.배경웹 개발에서 검색 엔진 최적화(SEO)는 매우 중요합니다. 효과적인 SEO 설정을 통해 검색 엔진에서 더 높은 순위를 얻고, 이로 인해 웹...",
    "content": "도입부이 포스트에서는 Stencil 프로젝트에서 SEO를 향상시키기 위해 RSS, sitemap, 및 robots.txt 파일을 정적 파일로 추가하고, 이를 Vercel을 통해 배포하는 과정을 소개하려고 합니다.배경웹 개발에서 검색 엔진 최적화(SEO)는 매우 중요합니다. 효과적인 SEO 설정을 통해 검색 엔진에서 더 높은 순위를 얻고, 이로 인해 웹사이트의 트래픽과 가시성이 증가할 수 있습니다.Stencil 프로젝트 설정Stencil은 웹 컴포넌트를 빌드하기 위한 도구이며, 다음과 같이 프로젝트를 설정합니다.  assets 디렉토리에 SEO 관련 파일을 저장합니다.  기본적으로 stencil읭 빌드 경로 www/assets/ 파일들이 해당 위치에 저장됩니다.  SEO폴더안의 정적, 혹은 동적으로 생성된 SEO 파일들을 vercel.json으로 라우팅처리를 해줍니다.파일 구조www/└── assets/SEO/├── sitemap.xml├── rss.xml└── robots.txtVercel에서의 배포Vercel을 사용하여 Stencil 프로젝트를 배포하는 과정은 다음과 같습니다.설정 파일 (vercel.json){  \"rewrites\": [    { \"source\": \"/sitemap.xml\", \"destination\": \"/assets/SEO/sitemap.xml\" },    { \"source\": \"/rss.xml\", \"destination\": \"/assets/SEO/rss.xml\" },    { \"source\": \"/robots.txt\", \"destination\": \"/assets/SEO/robots.txt\" }  ],  \"headers\": [    {      \"source\": \"/rss.xml\",      \"headers\": [        {          \"key\": \"Content-Type\",          \"value\": \"application/xml; charset=utf-8\"        }      ]    },    {      \"source\": \"/sitemap.xml\",      \"headers\": [        {          \"key\": \"Content-Type\",          \"value\": \"application/xml; charset=utf-8\"        }      ]    },    {      \"source\": \"/robots.txt\",      \"headers\": [        {          \"key\": \"Content-Type\",          \"value\": \"text/plain; charset=utf-8\"        },        {          \"key\": \"Cache-Control\",          \"value\": \"public, max-age=86400\"        }      ]    }  ]}라우팅과 파일 타입 설정위의 vercel.json 설정을 통해 각 파일에 적절한 Content-Type 헤더를 설정하고, 캐시 제어를 위한 Cache-Control 헤더를 추가하여 SEO를 최적화할 수 있습니다.결론이 글에서는 Stencil과 Vercel을 사용하여 RSS, sitemap, 및 robots.txt 파일을 관리하고 SEO를 개선하는 방법을 알아보았습니다.위의 SEO적용에서의 시행착오가 많았습니다. 프로젝트 루트에 해당파일을 위치시켜서 빌드하면 정적자산들이 제대로 빌드되지않는 현상을 겪었습니다.stencil에서의 정적자산들에 대한 기본위치는 리액트에서의 public처럼 assets에 위치해 있으며 vercel에서의 설정은 해당 assets가 빌드되고 최종적으로deploy되는 폴더인 www/assets/설정 및 저장한 폴더의 정적자산 PATH로 설정을 해줘야합니다.이 설정은 정적자산을 바탕으로 포스팅되었지만 해당 정적자산들을 동적으로 바꿔준다 하더라도 유효합니다."
  },
  
  {
    "title": "일렉트론에서의 서버 오류 핸들링",
    "url": "/posts/%EC%9D%BC%EB%A0%89%ED%8A%B8%EB%A1%A0%EC%97%90%EC%84%9C%EC%9D%98-%EC%84%9C%EB%B2%84-%ED%97%AC%EC%8A%A4%EC%B2%B4%ED%81%AC/",
    "categories": "Electron, Node.js, Socket Server",
    "tags": "Health Check, Server Handling, Socket Server, Electron",
    "date": "2024-05-10 00:00:00 +0800",
    





    
    "snippet": "개요데이터베이스 백업 로직 중 DB에 센서의 신호값을 저장하거나 , 갖가지 정보 등의 데이터를 소켓 서버에서 참조하는 과정에서 데이터의 무결성을 잃는 현상이 발생했습니다.이로 인해 소켓 서버가 에러를 일으켜 실행되지 않는 오류가 발생했습니다.첫번째는 백업로직중 , 관련된 서버의 동작을 일시정지하는것이 우선되어야겠지만 저는 어느상황에서든지 서버의 이상을...",
    "content": "개요데이터베이스 백업 로직 중 DB에 센서의 신호값을 저장하거나 , 갖가지 정보 등의 데이터를 소켓 서버에서 참조하는 과정에서 데이터의 무결성을 잃는 현상이 발생했습니다.이로 인해 소켓 서버가 에러를 일으켜 실행되지 않는 오류가 발생했습니다.첫번째는 백업로직중 , 관련된 서버의 동작을 일시정지하는것이 우선되어야겠지만 저는 어느상황에서든지 서버의 이상을 감지하고 서버가 자동으로 재실행되는 항상성을 유지하고싶었습니다.따라서 헬스체크의 필요성을 느끼고 일렉트론에서 특정 주기마다 헬스체크를 진행하여 의도치 않은 모든 오류를 핸들링하는 로직을 구현했습니다.추후에 DB백업로직이 실행되면 관련로직의 Socket을 끊고 재연결하고, DB 저장을 일시정지하는 로직을 추가개발해야합니다.헬스체크 로직시스템 환경마다 서버의 실행시간을 예측하기란 어려운 일입니다. 프로그램이 요구하는 시스템의 최소사양에서의 서버실행시간의 평균값인 3초보다 여유를 둔 5초 단위로서비스가 실행되면 헬스체크 메세지를 날리고 , 해당메세지의 respanse Message가 돌아오지못한다면(서버가 원활하지못한다면) 서버를 재실행합니다.재실행은 5초에서 10초 , 20초 , 40초 최대 1분간 기다리며 , 모든 재실행이 실패한다면 dialog로 사용자에게 서버가 원활하지않음을 알립니다.일렉트론 파일에서의 헬스체크 로직// electron 파일에서의 헬스체크 로직let consecutiveFailures = 0;const INITIAL_INTERVAL = 5000;const MAX_INTERVAL = 60000; // 최대 재시작 간격 (60초)let currentInterval = INITIAL_INTERVAL;async function socketHealthCheck() {  if (socketProcess) {    socketProcess.send(\"check-health\");    const isHealthy = await new Promise((resolve) =&gt; {      const timer = setTimeout(() =&gt; {        resolve(false);      }, 5000);      socketProcess.once(\"message\", (message) =&gt; {        if (message === \"socket server health!\") {          clearTimeout(timer);          resolve(true);          console.log(\"socket OK!!\");        }      });    });    if (!isHealthy) {      console.log(\"Socket server is unhealthy, restart\");      await restartSocketServer();      consecutiveFailures += 1;      currentInterval = Math.min(currentInterval * 2, MAX_INTERVAL); // 간격을 두 배로 늘립니다.      mainWindow.reload();      // 연속 실패가 최대 허용 횟수를 초과하면 경고 대화상자를 표시합니다.      if (consecutiveFailures &gt;= MAX_CONSECUTIVE_FAILURES) {        dialog.showMessageBox({          type: \"warning\",          title: \"Socket Server Warning\",          message:            \"소켓 서버가 건강하지 않습니다. 문제가 지속되면 시스템 관리자에게 문의하세요.\",          buttons: [\"확인\"]        });      }    } else {      consecutiveFailures = 0;      currentInterval = INITIAL_INTERVAL; // 서버가 건강하면 간격을 초기화합니다.    }  }}async function restartSocketServer() {  if (socketProcess) {    socketProcess.kill();    socketProcess = null;    await socketStart();    console.log(\"Socket server restarted\");  }}// 일정 간격으로 소켓 서버의 건강을 확인하고, 실패할 경우 간격을 조정합니다.function scheduleHealthCheck() {  setTimeout(() =&gt; {    socketHealthCheck().then(() =&gt; {      scheduleHealthCheck(); // 다음 건강 점검을 스케줄링합니다.    });  }, currentInterval);}scheduleHealthCheck(); // 건강 점검을 시작합니다."
  }
  
]

