[
  
  {
    "title": "Docker 이해하기: 컨테이너, 이미지, 볼륨, 그리고 빌드",
    "url": "/posts/%EB%8F%84%EC%BB%A4/",
    "categories": "기술, docker",
    "tags": "docker, 컨테이너, 이미지, 볼륨, 빌드",
    "date": "2024-05-14 00:00:00 +0800",
    





    
    "snippet": "Docker 소개Docker는 개발자들이 어디에서나 일관된 환경에서 애플리케이션을 실행할 수 있도록 컨테이너라는 형태로 소프트웨어를 패키징할 수 있는 플랫폼으로, 소프트웨어 개발에 혁명을 일으켰습니다. 이 글에서는 Docker가 등장한 배경, 그리고 컨테이너, 이미지, 볼륨, 빌드 프로세스 같은 주요 개념을 탐구하고, 이러한 개념들이 어떻게 효율적이고...",
    "content": "Docker 소개Docker는 개발자들이 어디에서나 일관된 환경에서 애플리케이션을 실행할 수 있도록 컨테이너라는 형태로 소프트웨어를 패키징할 수 있는 플랫폼으로, 소프트웨어 개발에 혁명을 일으켰습니다. 이 글에서는 Docker가 등장한 배경, 그리고 컨테이너, 이미지, 볼륨, 빌드 프로세스 같은 주요 개념을 탐구하고, 이러한 개념들이 어떻게 효율적이고 예측 가능한 소프트웨어 배포에 기여하는지 살펴보겠습니다.Docker의 등장Docker는 2013년에 도입되어, 서로 다른 컴퓨팅 환경에서 소프트웨어를 신뢰성 있게 구성하는 복잡성에 대응하였습니다. 컨테이너 기술을 활용하여 기반 인프라에 관계없이 코드가 동일하게 실행될 수 있도록 함으로써 개발, 테스트 및 배포 워크플로우를 단순화했습니다.주요 Docker 개념 이해컨테이너컨테이너는 코드, 런타임, 라이브러리 및 시스템 설정을 포함하여 애플리케이션 실행에 필요한 모든 것이 포함된 경량의 실행 가능한 패키지입니다. Docker 이미지를 기반으로 운영되며, 각 컨테이너는 서로 완전히 격리되어 있어 같은 호스트에서 실행되어도 서로 영향을 주지 않습니다. 컨테이너는 일시적인 상태를 가지며 실행 중일 때만 상태가 유지됩니다.이미지이미지는 컨테이너 실행에 필요한 파일과 설정이 포함된 불변의 스냅샷입니다. 컨테이너를 생성하는 데 사용되는 템플릿으로 생각할 수 있으며, 하나의 이미지에서 여러 컨테이너를 생성할 수 있습니다. 이미지는 대개 Dockerfile이라는 텍스트 문서를 통해 생성되며, 이 문서에는 컨테이너를 어떻게 구성할지에 대한 지시사항이 포함되어 있습니다.볼륨볼륨은 데이터를 컨테이너와 독립적으로 저장하고 관리할 수 있는 메커니즘입니다. 컨테이너는 일반적으로 불변하며 상태가 없지만, 볼륨을 사용하면 데이터를 영구적으로 저장하거나 여러 컨테이너 간에 공유할 수 있습니다. 볼륨은 호스트 시스템의 특정 부분에 데이터를 저장하며, 컨테이너가 삭제되어도 데이터는 유지됩니다.빌드 프로세스빌드 프로세스는 소스 코드로부터 Docker 이미지를 생성하는 과정입니다. Dockerfile에 정의된 지시사항을 순차적으로 실행하여 이미지의 새로운 계층을 추가하며, 이 계층들이 최종 이미지를 구성합니다. 이렇게 생성된 이미지는 재사용이 가능하며 다른 시스템에 쉽게 배포할 수 있습니다.결론Docker의 컨테이너, 이미지, 볼륨, 빌드 프로세스를 이해하고 올바르게 사용하는 것은 소프트웨어 개발 주기를 향상시키는 데 필수적입니다. 이러한 구성 요소들은 모두 Docker 생태계 내에서 중요한 역할을 하며, 개발자들이 워크플로우를 간소화하고 환경에 관계없이 일관된 결과를 달성할 수 있도록 돕습니다.이 글이 여러분의 프로젝트에서 Docker의 힘을 활용하는 데 도움이 되기를 바랍니다!"
  },
  
  {
    "title": "Electron에서 alert 사용시 input 읽기 전용 문제 해결",
    "url": "/posts/Electron%EC%97%90%EC%84%9C%EC%9D%98-input%EC%9D%B4-%EC%9D%98%EB%8F%84%EC%B9%98%EC%95%8A%EA%B2%8C-readonly%EB%A1%9C-%EA%B0%95%EC%A0%9C%EB%90%98%EB%8A%94-%ED%98%84%EC%83%81/",
    "categories": "Electron, troubleshooting",
    "tags": "",
    "date": "2024-05-13 00:00:00 +0800",
    





    
    "snippet": "개요Electron 애플리케이션에서 alert() 함수를 사용할 때, input 태그가 읽기 전용으로 설정되는 현상이 종종 발생합니다. 이 현상은 Electron의 구조적 특성 때문에 나타나는 문제로, 이해를 돕기 위해 문제의 원인과 해결 방안을 상세히 설명하겠습니다.원인 분석Electron은 Chromium과 Node.js를 기반으로 하는데, 이는 ...",
    "content": "개요Electron 애플리케이션에서 alert() 함수를 사용할 때, input 태그가 읽기 전용으로 설정되는 현상이 종종 발생합니다. 이 현상은 Electron의 구조적 특성 때문에 나타나는 문제로, 이해를 돕기 위해 문제의 원인과 해결 방안을 상세히 설명하겠습니다.원인 분석Electron은 Chromium과 Node.js를 기반으로 하는데, 이는 Electron이 브라우저와 유사한 환경을 제공하지만, 일부 특성이 다르다는 것을 의미합니다. 일반적인 웹 브라우저에서는 alert(), prompt(), confirm() 같은 함수들이 동기적으로 실행되어, 사용자의 입력을 기다리는 동안 전체 렌더링 엔진을 멈춥니다. 그러나 Electron에서는 이러한 함수들이 메인 프로세스의 시스템 대화 상자를 통해 실행되며, 이 과정에서 렌더러 프로세스는 계속해서 비동기적으로 동작합니다.이 때문에, 메인 스레드가 시스템 모달을 실행하면서 렌더러 프로세스의 입력 필드 등이 일시적으로 읽기 전용 상태가 될 수 있습니다. 이는 메인 프로세스와 렌더러 프로세스가 독립적으로 작동하면서 발생하는 동기화 문제로 볼 수 있습니다.해결 방안비동기 대화 상자 사용하기Electron의 dialog 모듈을 사용하여 비동기적으로 메시지 박스를 표시할 수 있습니다. 이 방법은 렌더러 프로세스를 차단하지 않고 사용자의 입력을 받을 수 있습니다.const { dialog } = require(\"electron\");dialog  .showMessageBox({    type: \"info\",    title: \"Information\",    message: \"This is an important message.\"  })  .then((result) =&gt; {    console.log(result.response);  });사용자 정의 모달 구현하기HTML과 CSS를 활용하여 사용자 정의 모달을 만들어 사용하는 것도 좋은 방법입니다. 이는 UI/UX를 완전히 제어할 수 있으며, 기존의 웹 기술을 활용하므로 개발자에게 친숙합니다.&lt;div id=\"myModal\" class=\"modal\"&gt;  &lt;div class=\"modal-content\"&gt;    &lt;span class=\"close\"&gt;&amp;times;&lt;/span&gt;    &lt;p&gt;Some text in the Modal..&lt;/p&gt;  &lt;/div&gt;&lt;/div&gt;&lt;style&gt;.modal {    display: none;    position: fixed;    z-index: 1;    left: 0;    top: 0;    width: 100%;    height: 100%;    overflow: auto;    background-color: rgb(0,0,0);    background-color: rgba(0,0,0,0.4);}&lt;/style&gt;const modal = document.getElementById(\"myModal\");const span = document.getElementsByClassName(\"close\")[0];span.onclick = function() {    modal.style.display = \"none\";}window.onclick = function(event) {    if (event.target == modal) {        modal.style.display = \"none\";    }}결론Electron에서 alert() 함수의 사용은 입력 필드를 일시적으로 읽기 전용으로 만들 수 있습니다. 이 문제를 해결하기 위해 비동기 대화 상자 사용이나 사용자 정의 모달 구현을 추천합니다. 이 방법들을 통해 사용자 경험을 개선하고 애플리케이션의 효율성을 높일 수 있습니다.커스텀 alert나 modal, dialog 사용함으로써 Electron의 에러를 회피해야합니다. 처음 이 에러를 접하면 어떠한 동작때문인가 싶을텐데해당 이벤트(클릭,handler함수 실행의 사이드이페트)보단 alert그 자체의 문제였어서 당황하였습니다."
  },
  
  {
    "title": "Stencil에서 정적 파일을 이용한 SEO 최적화: RSS, Sitemap, Robots.txt 설정하기",
    "url": "/posts/stencil%EC%97%90%EC%84%9C-%EC%A0%95%EC%A0%81%ED%8C%8C%EC%9D%BC-%EC%B6%94%EA%B0%80%ED%95%B4-SEO%EC%B5%9C%EC%A0%81%ED%99%94%ED%95%98%EA%B8%B0/",
    "categories": "web-development, seo, stencil, vercel, deploy",
    "tags": "",
    "date": "2024-05-12 00:00:00 +0800",
    





    
    "snippet": "개요이 포스트에서는 Stencil 프로젝트에서 SEO를 향상시키기 위해 RSS, sitemap, 및 robots.txt 파일을 정적 파일로 추가하고, 이를 Vercel을 통해 배포하는 과정을 소개하려고 합니다.배경웹 개발에서 검색 엔진 최적화(SEO)는 매우 중요합니다. 효과적인 SEO 설정을 통해 검색 엔진에서 더 높은 순위를 얻고, 이로 인해 웹사...",
    "content": "개요이 포스트에서는 Stencil 프로젝트에서 SEO를 향상시키기 위해 RSS, sitemap, 및 robots.txt 파일을 정적 파일로 추가하고, 이를 Vercel을 통해 배포하는 과정을 소개하려고 합니다.배경웹 개발에서 검색 엔진 최적화(SEO)는 매우 중요합니다. 효과적인 SEO 설정을 통해 검색 엔진에서 더 높은 순위를 얻고, 이로 인해 웹사이트의 트래픽과 가시성이 증가할 수 있습니다.Stencil 프로젝트 설정Stencil은 웹 컴포넌트를 빌드하기 위한 도구이며, 다음과 같이 프로젝트를 설정합니다.  assets 디렉토리에 SEO 관련 파일을 저장합니다.  기본적으로 stencil읭 빌드 경로 www/assets/ 파일들이 해당 위치에 저장됩니다.  SEO폴더안의 정적, 혹은 동적으로 생성된 SEO 파일들을 vercel.json으로 라우팅처리를 해줍니다.파일 구조www/└── assets/SEO/├── sitemap.xml├── rss.xml└── robots.txtVercel에서의 배포Vercel을 사용하여 Stencil 프로젝트를 배포하는 과정은 다음과 같습니다.설정 파일 (vercel.json){  \"rewrites\": [    { \"source\": \"/sitemap.xml\", \"destination\": \"/assets/SEO/sitemap.xml\" },    { \"source\": \"/rss.xml\", \"destination\": \"/assets/SEO/rss.xml\" },    { \"source\": \"/robots.txt\", \"destination\": \"/assets/SEO/robots.txt\" }  ],  \"headers\": [    {      \"source\": \"/rss.xml\",      \"headers\": [        {          \"key\": \"Content-Type\",          \"value\": \"application/xml; charset=utf-8\"        }      ]    },    {      \"source\": \"/sitemap.xml\",      \"headers\": [        {          \"key\": \"Content-Type\",          \"value\": \"application/xml; charset=utf-8\"        }      ]    },    {      \"source\": \"/robots.txt\",      \"headers\": [        {          \"key\": \"Content-Type\",          \"value\": \"text/plain; charset=utf-8\"        },        {          \"key\": \"Cache-Control\",          \"value\": \"public, max-age=86400\"        }      ]    }  ]}라우팅과 파일 타입 설정위의 vercel.json 설정을 통해 각 파일에 적절한 Content-Type 헤더를 설정하고, 캐시 제어를 위한 Cache-Control 헤더를 추가하여 SEO를 최적화할 수 있습니다.결론이 글에서는 Stencil과 Vercel을 사용하여 RSS, sitemap, 및 robots.txt 파일을 관리하고 SEO를 개선하는 방법을 알아보았습니다.위의 SEO적용에서의 시행착오가 많았습니다. 프로젝트 루트에 해당파일을 위치시켜서 빌드하면 정적자산들이 제대로 빌드되지않는 현상을 겪었습니다.stencil에서의 정적자산들에 대한 기본위치는 리액트에서의 public처럼 assets에 위치해 있으며 vercel에서의 설정은 해당 assets가 빌드되고 최종적으로deploy되는 폴더인 www/assets/설정 및 저장한 폴더의 정적자산 PATH로 설정을 해줘야합니다.이 설정은 정적자산을 바탕으로 포스팅되었지만 해당 정적자산들을 동적으로 바꿔준다 하더라도 유효합니다."
  },
  
  {
    "title": "일렉트론에서의 서버 오류 핸들링",
    "url": "/posts/%EC%9D%BC%EB%A0%89%ED%8A%B8%EB%A1%A0%EC%97%90%EC%84%9C%EC%9D%98-%EC%84%9C%EB%B2%84-%ED%97%AC%EC%8A%A4%EC%B2%B4%ED%81%AC/",
    "categories": "Electron, Node.js, Socket Server",
    "tags": "Health Check, Server Handling, Socket Server, Electron, troubleshooting",
    "date": "2024-05-10 00:00:00 +0800",
    





    
    "snippet": "개요데이터베이스 백업 로직 중 DB에 센서의 신호값을 저장하거나 , 갖가지 정보 등의 데이터를 소켓 서버에서 참조하는 과정에서 데이터의 무결성을 잃는 현상이 발생했습니다.이로 인해 소켓 서버가 에러를 일으켜 실행되지 않는 오류가 발생했습니다.첫번째는 백업로직중 , 관련된 서버의 동작을 일시정지하는것이 우선되어야겠지만 저는 어느상황에서든지 서버의 이상을...",
    "content": "개요데이터베이스 백업 로직 중 DB에 센서의 신호값을 저장하거나 , 갖가지 정보 등의 데이터를 소켓 서버에서 참조하는 과정에서 데이터의 무결성을 잃는 현상이 발생했습니다.이로 인해 소켓 서버가 에러를 일으켜 실행되지 않는 오류가 발생했습니다.첫번째는 백업로직중 , 관련된 서버의 동작을 일시정지하는것이 우선되어야겠지만 저는 어느상황에서든지 서버의 이상을 감지하고 서버가 자동으로 재실행되는 항상성을 유지하고싶었습니다.따라서 헬스체크의 필요성을 느끼고 일렉트론에서 특정 주기마다 헬스체크를 진행하여 의도치 않은 모든 오류를 핸들링하는 로직을 구현했습니다.추후에 DB백업로직이 실행되면 관련로직의 Socket을 끊고 재연결하고, DB 저장을 일시정지하는 로직을 추가개발해야합니다.헬스체크 로직시스템 환경마다 서버의 실행시간을 예측하기란 어려운 일입니다. 프로그램이 요구하는 시스템의 최소사양에서의 서버실행시간의 평균값인 3초보다 여유를 둔 5초 단위로서비스가 실행되면 헬스체크 메세지를 날리고 , 해당메세지의 respanse Message가 돌아오지못한다면(서버가 원활하지못한다면) 서버를 재실행합니다.재실행은 5초에서 10초 , 20초 , 40초 최대 1분간 기다리며 , 모든 재실행이 실패한다면 dialog로 사용자에게 서버가 원활하지않음을 알립니다.일렉트론 파일에서의 헬스체크 로직// electron 파일에서의 헬스체크 로직let consecutiveFailures = 0;const INITIAL_INTERVAL = 5000;const MAX_INTERVAL = 60000; // 최대 재시작 간격 (60초)let currentInterval = INITIAL_INTERVAL;async function socketHealthCheck() {  if (socketProcess) {    socketProcess.send(\"check-health\");    const isHealthy = await new Promise((resolve) =&gt; {      const timer = setTimeout(() =&gt; {        resolve(false);      }, 5000);      socketProcess.once(\"message\", (message) =&gt; {        if (message === \"socket server health!\") {          clearTimeout(timer);          resolve(true);          console.log(\"socket OK!!\");        }      });    });    if (!isHealthy) {      console.log(\"Socket server is unhealthy, restart\");      await restartSocketServer();      consecutiveFailures += 1;      currentInterval = Math.min(currentInterval * 2, MAX_INTERVAL); // 간격을 두 배로 늘립니다.      mainWindow.reload();      // 연속 실패가 최대 허용 횟수를 초과하면 경고 대화상자를 표시합니다.      if (consecutiveFailures &gt;= MAX_CONSECUTIVE_FAILURES) {        dialog.showMessageBox({          type: \"warning\",          title: \"Socket Server Warning\",          message:            \"소켓 서버가 건강하지 않습니다. 문제가 지속되면 시스템 관리자에게 문의하세요.\",          buttons: [\"확인\"]        });      }    } else {      consecutiveFailures = 0;      currentInterval = INITIAL_INTERVAL; // 서버가 건강하면 간격을 초기화합니다.    }  }}async function restartSocketServer() {  if (socketProcess) {    socketProcess.kill();    socketProcess = null;    await socketStart();    console.log(\"Socket server restarted\");  }}// 일정 간격으로 소켓 서버의 건강을 확인하고, 실패할 경우 간격을 조정합니다.function scheduleHealthCheck() {  setTimeout(() =&gt; {    socketHealthCheck().then(() =&gt; {      scheduleHealthCheck(); // 다음 건강 점검을 스케줄링합니다.    });  }, currentInterval);}scheduleHealthCheck(); // 건강 점검을 시작합니다."
  }
  
]

