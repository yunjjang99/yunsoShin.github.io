[
  
  {
    "title": "Next.js와 React Server Components (RSC) 이해하기",
    "url": "/posts/Next.js%EC%99%80-React-Server-Components-(RSC)-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/",
    "categories": "Next.js, React",
    "tags": "Next.js, ServerComponents",
    "date": "2024-05-21 00:00:00 +0900",
    





    
    "snippet": "개요Next.js는 React 기반의 프레임워크로, 서버 측 렌더링(SSR), 정적 사이트 생성(SSG) 등의 기능을 통해 React 애플리케이션의 성능을 최적화합니다. Next.js는 React Server Components 개념을 도입하여 서버 컴포넌트와 클라이언트 컴포넌트를 구별합니다. 이러한 기술적 발전과 구분 방법을 다음과 같이 설명하고, ...",
    "content": "개요Next.js는 React 기반의 프레임워크로, 서버 측 렌더링(SSR), 정적 사이트 생성(SSG) 등의 기능을 통해 React 애플리케이션의 성능을 최적화합니다. Next.js는 React Server Components 개념을 도입하여 서버 컴포넌트와 클라이언트 컴포넌트를 구별합니다. 이러한 기술적 발전과 구분 방법을 다음과 같이 설명하고, 이를 최적화하여 활용하는 방법을 소개합니다.기술적인 발전 과정Next.js의 서버 컴포넌트와 클라이언트 컴포넌트 구분은 React의 발전과 밀접한 관련이 있습니다. 초기에는 SSR(Server-Side Rendering)과 CSR(Client-Side Rendering)을 사용했으며, 이후 정적 사이트 생성(SSG), Incremental Static Regeneration(ISR) 등을 도입하여 성능을 최적화해 왔습니다.초기 단계: SSR과 CSRNext.js의 초기 버전에서는 SSR(Server-Side Rendering)과 CSR(Client-Side Rendering)을 주로 사용했습니다. SSR은 서버에서 HTML을 생성하여 클라이언트로 전송하고, CSR은 클라이언트에서 모든 렌더링을 담당합니다.정적 사이트 생성(SSG)Next.js는 이후 정적 사이트 생성(SSG) 기능을 도입하여 빌드 시점에 HTML을 생성하여 CDN에 배포할 수 있게 했습니다. 이를 통해 정적 페이지의 성능을 크게 향상시켰습니다.Incremental Static Regeneration(ISR)Next.js는 Incremental Static Regeneration(ISR)을 도입하여 정적 페이지의 일부만 재생성할 수 있게 했습니다. 이를 통해 페이지 업데이트 시 전체 사이트를 다시 빌드하지 않고 필요한 부분만 갱신할 수 있습니다.React Server ComponentsReact는 React Server Components를 도입하여 서버에서 컴포넌트를 렌더링하고, 클라이언트로 필요한 최소한의 JavaScript만 전송하는 방식을 제안했습니다. Next.js는 이를 빠르게 채택하여 서버 컴포넌트와 클라이언트 컴포넌트를 명확히 구분할 수 있게 했습니다. 이 방식은 서버에서 데이터를 가져오고 처리하여 클라이언트로 전달하는 과정을 단순화합니다.NextJS Server ComponentsNext.js는 getServerSideProps, getStaticProps, getStaticPaths 등의 메서드를 제공하여 서버 사이드에서 데이터를 페칭하고 페이지 컴포넌트로 전달할 수 있게 합니다. 이러한 함수는 특정 페이지 컴포넌트와 연동되어 서버에서 데이터를 미리 가져오고 렌더링하는 과정을 단순화합니다.리액트에서의 Server Components를 SSR로 직접구현기본적으로 리액트는 CSR을 지원하는 ‘라이브러리’이기 떄문에서버컴포넌트를 구성하려면 서버의 구성이 필요합니다1. 기본 서버 사이드 렌더링 설정먼저, Express와 React를 사용하여 서버 사이드 렌더링을 설정합니다.package.json 설치{  \"name\": \"ssr-example\",  \"version\": \"1.0.0\",  \"main\": \"server.js\",  \"scripts\": {    \"start\": \"node server.js\"  },  \"dependencies\": {    \"express\": \"^4.17.1\",    \"react\": \"^17.0.2\",    \"react-dom\": \"^17.0.2\",    \"node-fetch\": \"^2.6.1\",    \"@babel/core\": \"^7.12.3\",    \"@babel/preset-env\": \"^7.12.1\",    \"@babel/preset-react\": \"^7.12.1\",    \"babel-register\": \"^6.26.0\"  }}추가로 바벨 종속성 등록 및 호환성체크server.jsimport express from \"express\";import React from \"react\";import { renderToString } from \"react-dom/server\";import App from \"./src/App\";import fetch from \"node-fetch\";const app = express();app.use(express.static(\"public\"));app.get(\"/\", async (req, res) =&gt; {  const response = await fetch(\"https://api.example.com/data\");  const data = await response.text();  const appHTML = renderToString(&lt;App data={data} /&gt;);  res.send(`    &lt;!DOCTYPE html&gt;    &lt;html&gt;      &lt;head&gt;        &lt;title&gt;SSR Example&lt;/title&gt;      &lt;/head&gt;      &lt;body&gt;        &lt;div id=\"root\"&gt;${appHTML}&lt;/div&gt;        &lt;script&gt;window.__INITIAL_DATA__ = ${JSON.stringify(data).replace(          /&lt;/g,          \"\\\\u003c\"        )}&lt;/script&gt;        &lt;script src=\"/client.js\"&gt;&lt;/script&gt;      &lt;/body&gt;    &lt;/html&gt;  `);});app.listen(3000, () =&gt; {  console.log(\"Server is running on http://localhost:3000\");});Express로 Node서버 구성src/App.jsimport React from \"react\";export default function App() {  return &lt;div&gt;Hello from the server!&lt;/div&gt;;}2. 클라이언트 하이드레이션 설정클라이언트에서 서버에서 전송된 HTML을 하이드레이션합니다.public/client.jsimport React from \"react\";import ReactDOM from \"react-dom\";import App from \"../src/App\";ReactDOM.hydrate(&lt;App /&gt;, document.getElementById(\"root\"));3. 데이터 페칭을 포함한 서버 컴포넌트서버에서 데이터를 페칭하여 렌더링하는 컴포넌트를 추가해보겠습니다.src/App.js (데이터 페칭 추가)import React from \"react\";export default function App({ data }) {  return (    &lt;div&gt;      &lt;h1&gt;Data from server:&lt;/h1&gt;      &lt;p&gt;{data}&lt;/p&gt;    &lt;/div&gt;  );}server.js (데이터 페칭 추가)const express = require(\"express\");const React = require(\"react\");const { renderToString } = require(\"react-dom/server\");const App = require(\"./src/App\").default;const fetch = require(\"node-fetch\");const app = express();app.use(express.static(\"public\"));app.get(\"/\", async (req, res) =&gt; {  const response = await fetch(\"https://api.example.com/data\");  const data = await response.text();  const appHTML = renderToString(&lt;App data={data} /&gt;);  res.send(`    &lt;!DOCTYPE html&gt;    &lt;html&gt;      &lt;head&gt;        &lt;title&gt;SSR Example&lt;/title&gt;      &lt;/head&gt;      &lt;body&gt;        &lt;div id=\"root\"&gt;${appHTML}&lt;/div&gt;        &lt;script&gt;window.__INITIAL_DATA__ = ${JSON.stringify(data)}&lt;/script&gt;        &lt;script src=\"/client.js\"&gt;&lt;/script&gt;      &lt;/body&gt;    &lt;/html&gt;  `);});app.listen(3000, () =&gt; {  console.log(\"Server is running on http://localhost:3000\");});public/client.js (하이드레이션 수정)import React from \"react\";import ReactDOM from \"react-dom\";import App from \"../src/App\";const data = window.__INITIAL_DATA__;ReactDOM.hydrate(&lt;App data={data} /&gt;, document.getElementById(\"root\"));4.최적화: 코드 스플리팅 및 React.lazyReact.lazy와 Suspense를 사용하여 코드 스플리팅으로 최적화합니다.src/App.js (코드 스플리팅 추가)import React, { Suspense } from \"react\";const DataComponent = React.lazy(() =&gt; import(\"./DataComponent\"));export default function App({ data }) {  return (    &lt;div&gt;      &lt;h1&gt;Data from server:&lt;/h1&gt;      &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;        &lt;DataComponent data={data} /&gt;      &lt;/Suspense&gt;    &lt;/div&gt;  );}src/DataComponent.jsimport React from \"react\";export default function DataComponent({ data }) {  return &lt;p&gt;{data}&lt;/p&gt;;}5. 최적화: 서버 사이드 데이터 로딩서버에서 데이터를 미리 로딩하고 클라이언트로 전달하여 네트워크 요청을 최소화합니다.server.js (서버 사이드 데이터 로딩 추가)const express = require(\"express\");const React = require(\"react\");const { renderToString } = require(\"react-dom/server\");const App = require(\"./src/App\").default;const fetch = require(\"node-fetch\");const app = express();app.use(express.static(\"public\"));app.get(\"/\", async (req, res) =&gt; {  const response = await fetch(\"https://api.example.com/data\");  const data = await response.text();  const appHTML = renderToString(&lt;App data={data} /&gt;);  res.send(`    &lt;!DOCTYPE html&gt;    &lt;html&gt;      &lt;head&gt;        &lt;title&gt;SSR Example&lt;/title&gt;      &lt;/head&gt;      &lt;body&gt;        &lt;div id=\"root\"&gt;${appHTML}&lt;/div&gt;        &lt;script&gt;window.__INITIAL_DATA__ = ${JSON.stringify(data)}&lt;/script&gt;        &lt;script src=\"/client.js\"&gt;&lt;/script&gt;      &lt;/body&gt;    &lt;/html&gt;  `);});app.listen(3000, () =&gt; {  console.log(\"Server is running on http://localhost:3000\");});React에서 React Server Components (RSC) 구현 패턴React에서 RSC를 직접 구현하려면 다음과 같은 과정이 필요합니다:  서버 컴포넌트 작성: 서버에서 렌더링할 컴포넌트를 작성합니다.  서버 설정: Express 또는 Koa 같은 Node.js 서버를 설정하여 서버 컴포넌트를 렌더링합니다.  데이터 페칭 및 렌더링: 서버 컴포넌트에서 필요한 데이터를 페칭하고 HTML로 렌더링합니다.  클라이언트 전송: 렌더링된 HTML과 필요한 데이터만 클라이언트로 전송합니다.  클라이언트 하이드레이션: 클라이언트에서 받은 HTML을 하이드레이션하여 상호작용을 추가합니다.NextJS에서의 Server Components 구현 방법Next.js는 페이지 수준에서 데이터 페칭 및 서버 사이드 렌더링을 지원합니다. getServerSideProps 함수를 사용하여 서버 측에서 데이터를 페칭할 수 있습니다.사용 시 주의사항  데이터 페칭: 서버 컴포넌트에서만 데이터 페칭을 수행하고, 클라이언트 컴포넌트에서는 데이터 페칭을 피하는 것이 좋습니다. 이는 서버에서 데이터를 가져오는 것이 더 효율적이기 때문입니다.  상태 관리: 클라이언트 컴포넌트에서는 상태 관리를 사용하여 사용자와의 상호작용을 처리합니다. 서버 컴포넌트에서는 상태 관리를 사용하지 않습니다.  보안: 서버 컴포넌트에서는 클라이언트로 전송되기 전에 모든 데이터가 서버에서 렌더링되므로 보안상 이점이 있습니다.// app/serverComponent.server.jsimport fetchData from 'path/to/fetchData';export default function ServerComponent() {  const data = fetchData();  return (    &lt;div&gt;      &lt;h1&gt;Server Component&lt;/h1&gt;      &lt;p&gt;Data: {data}&lt;/p&gt;    &lt;/div&gt;  );}// app/clientComponent.client.js\"use client\";import { useState } from 'react';export default function ClientComponent() {  const [count, setCount] = useState(0);  return (    &lt;div&gt;      &lt;h1&gt;Client Component&lt;/h1&gt;      &lt;p&gt;Count: {count}&lt;/p&gt;      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;    &lt;/div&gt;  );}React Server Components (RSC)와 Next.js에서의 구현 차이점  설정과 구성:          React: 서버 설정(예: Express, Koa)을 직접 구성해야 하며, 데이터 페칭과 렌더링을 직접 처리합니다.      Next.js: 파일 시스템 기반 라우팅과 자동 설정을 통해 구성 작업을 최소화하며, 서버 컴포넌트와 클라이언트 컴포넌트를 쉽게 구분하고 사용할 수 있습니다.        데이터 페칭과 렌더링:          React: 데이터 페칭과 렌더링 로직을 직접 작성해야 하며, 서버와 클라이언트 간의 데이터 전송을 직접 관리해야 합니다.      Next.js: getServerSideProps와 getStaticProps 같은 메서드를 사용하여 데이터 페칭과 렌더링을 자동으로 처리하며, 클라이언트로 전송되는 데이터를 최적화합니다.        자동 최적화:          React: 모든 최적화 작업을 직접 수행해야 합니다.      Next.js: 자동 최적화를 통해 서버에서 렌더링된 결과와 클라이언트 측 상호작용을 최적화합니다.            개발 편의성:          React: 초기 설정과 구성이 복잡하며, 모든 작업을 직접 관리해야 합니다.      Next.js: 설정과 구성이 간편하며, 서버 컴포넌트와 클라이언트 컴포넌트를 쉽게 구분하고 사용할 수 있어 개발 편의성이 높습니다.리액트의 복잡한 설정이 필요없어지니 확실히 프레임워크는 프레임워크입니다.다음은 NextJS에서의 활용방법들입니다.        Next.js에서의 활용    1. 컴포넌트 구분 명확히 하기    서버 컴포넌트와 클라이언트 컴포넌트를 명확히 구분하는 것은 중요합니다. 파일 네이밍과 디렉토리 구조를 통해 이를 명확히 하는 것이 좋습니다.    - components/  - ServerComponent.server.js  - ClientComponent.client.js        서버 컴포넌트는 서버에서만 렌더링되므로 보안에 민감한 데이터를 처리할 수 있으며, 클라이언트 컴포넌트는 사용자 인터랙션을 담당합니다.    2. 데이터 페칭과 상태 관리 최적화    서버 컴포넌트에서 데이터 페칭    서버 컴포넌트에서 데이터를 페칭하는 것이 성능 면에서 유리합니다. getServerSideProps 또는 getStaticProps를 사용하여 데이터를 서버에서 미리 로드합니다.    // components/ServerComponent.server.jsimport fetchData from \"path/to/fetchData\";export default function ServerComponent() {  const data = fetchData();  return (    &lt;div&gt;      &lt;h1&gt;Server Component&lt;/h1&gt;      &lt;p&gt;Data: {data}&lt;/p&gt;    &lt;/div&gt;  );}        클라이언트 컴포넌트에서 상태 관리    클라이언트 컴포넌트에서는 상태 관리 라이브러리(예: Redux, Zustand)를 사용하여 사용자 인터랙션을 처리합니다.    // components/ClientComponent.client.js\"use client\";import { useState } from \"react\";export default function ClientComponent() {  const [count, setCount] = useState(0);  return (    &lt;div&gt;      &lt;h1&gt;Client Component&lt;/h1&gt;      &lt;p&gt;Count: {count}&lt;/p&gt;      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;    &lt;/div&gt;  );}        하이드레이션 문제의 최적화 전후 코드 비교    문제: 하이드레이션 최적화    서버에서 렌더링된 HTML을 클라이언트에서 하이드레이션할 때 발생하는 성능 문제와 일관성 문제를 해결해야 했습니다. 특히, 초기 로드 시 느린 하이드레이션 속도는 사용자 경험을 저하시킬 수 있습니다.    문제 발생 전 코드    ServerComponent.server.js    export default function ServerComponent() {  return (    &lt;div&gt;      &lt;h1&gt;Server Component&lt;/h1&gt;      &lt;p&gt;Data: Static data&lt;/p&gt;    &lt;/div&gt;  );}        ClientComponent.client.js    \"use client\";import { useState, useEffect } from \"react\";export default function ClientComponent() {  const [data, setData] = useState(null);  useEffect(() =&gt; {    fetch(\"/api/data\")      .then((response) =&gt; response.json())      .then((data) =&gt; setData(data));  }, []);  return (    &lt;div&gt;      &lt;h1&gt;Client Component&lt;/h1&gt;      &lt;p&gt;Data: {data}&lt;/p&gt;    &lt;/div&gt;  );}        이 코드는 서버에서 렌더링된 후 클라이언트에서 데이터를 다시 페칭합니다. 이는 불필요한 네트워크 요청을 초래하고, 하이드레이션 속도를 저하시킵니다.    문제 해결 후 코드    ServerComponent.server.js    import fetchData from \"path/to/fetchData\";export default function ServerComponent({ initialData }) {  return (    &lt;div&gt;      &lt;h1&gt;Server Component&lt;/h1&gt;      &lt;p&gt;Data: {initialData}&lt;/p&gt;    &lt;/div&gt;  );}// getServerSideProps.jsexport async function getServerSideProps() {  const data = await fetchData();  return { props: { initialData: data } };}        ClientComponent.client.js    \"use client\";import { useState } from \"react\";export default function ClientComponent({ initialData }) {  const [data] = useState(initialData);  return (    &lt;div&gt;      &lt;h1&gt;Client Component&lt;/h1&gt;      &lt;p&gt;Data: {data}&lt;/p&gt;    &lt;/div&gt;  );}        이 코드는 서버에서 데이터를 미리 페칭하고 클라이언트로 전달합니다. 이렇게 하면 클라이언트에서 추가적인 네트워크 요청 없이 하이드레이션이 이루어져 초기 로드 속도가 개선됩니다. 또한, React의 상태 관리를 사용하여 초기 데이터를 설정하므로 데이터 일관성 문제가 해결됩니다.    3. 코드 스플리팅과 동적 임포트 사용    큰 애플리케이션에서는 성능 최적화를 위해 코드 스플리팅과 동적 임포트를 사용하는 것이 중요합니다. 이를 통해 초기 로드 시간을 줄이고 필요한 부분만 로드할 수 있습니다.    // components/ClientComponent.client.jsimport dynamic from \"next/dynamic\";const HeavyComponent = dynamic(() =&gt; import(\"./HeavyComponent.client\"), {  ssr: false,  loading: () =&gt; &lt;p&gt;Loading...&lt;/p&gt;});export default function ClientComponent() {  return (    &lt;div&gt;      &lt;h1&gt;Client Component&lt;/h1&gt;      &lt;HeavyComponent /&gt;    &lt;/div&gt;  );}        결론    이번 포스팅은 직접 React로 NextJS의 SSR 기능을 모방하고 , 이를 NextJS 에서는 어떻게 활용하는지 포스팅하였습니다다음 포스팅은 Vercel팀이 어떻게 nextJS에 서버컴포넌트를 구현했는지 오픈소스를 까서보는 시간이 될것같습니다.  "
  },
  
  {
    "title": "AWS Docker 컨테이너의 MariaDB 데이터베이스 덤프 파일 생성 및 복사",
    "url": "/posts/AWS-Docker-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EC%9D%98-MariaDB-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EB%8D%A4%ED%94%84-%ED%8C%8C%EC%9D%BC-%EC%83%9D%EC%84%B1-%EB%B0%8F-%EB%B3%B5%EC%82%AC/",
    "categories": "AWS, Docker, MariaDB, Backup",
    "tags": "",
    "date": "2024-05-21 00:00:00 +0900",
    





    
    "snippet": "AWS Docker 컨테이너의 MariaDB 데이터베이스 덤프 파일 생성 및 복사개요이 블로그 글에서는 AWS 인스턴스의 Docker 컨테이너에서 MariaDB 데이터베이스 덤프 파일을 생성하고,이를 호스트 로컬 폴더로 복사하는 방법을 단계별로 설명합니다.현재 나의 상황은 AWS 인스턴스로 올라가있는 서버와해당 서버가 이용중인 DB가 도커환경에서 구동...",
    "content": "AWS Docker 컨테이너의 MariaDB 데이터베이스 덤프 파일 생성 및 복사개요이 블로그 글에서는 AWS 인스턴스의 Docker 컨테이너에서 MariaDB 데이터베이스 덤프 파일을 생성하고,이를 호스트 로컬 폴더로 복사하는 방법을 단계별로 설명합니다.현재 나의 상황은 AWS 인스턴스로 올라가있는 서버와해당 서버가 이용중인 DB가 도커환경에서 구동중입니다SSH로 공유된 원격 인스턴스에 접근하여 인스턴스 내부에서 돌아가는 DB환경을 로컬로 재구성하기위해서 필요한 작업을 합니다.1. Docker 컨테이너 내부에서 MariaDB 덤프 파일 생성먼저 Docker 컨테이너 내부에 접속하여 MariaDB 데이터베이스 덤프 파일을 생성합니다.컨테이너 이름을 사용하는 방법:sudo docker exec -it [container_name] /bin/bash컨테이너 ID를 사용하는 방법:sudo docker exec -it [container_id] /bin/bash컨테이너 내부에서 mysqldump 명령어를 실행하여 덤프 파일을 생성합니다:mysqldump  -uroot -p [password] [database] &gt; /tmp/[dumpFileName].sql열 통계 정보 포함 비활성화:MySQL 8.0.21부터 mysqldump는 기본적으로 열 통계 정보를 덤프 파일에 포함시킵니다. 그러나 일부 MariaDB 버전 또는 특정 설정에서는 이 기능이 호환되지 않을 수 있습니다. 따라서 이 옵션을 사용하면 열 통계 정보를 포함하지 않도록 설정할 수 있습니다.만약 mariaDB를 사용하는 환경이고 , 아래와같은 에러가 발생한다면 열통계를 끄는 옵션을 추가하여주세요mysqldump: Couldn't execute 'SELECT COLUMN_NAME,JSON_EXTRACT(HISTOGRAM, '$.\"number-of-buckets-specified\"')FROM information_schema.COLUMN_STATISTICSWHERE SCHEMA_NAME = '[DatabaseName]'AND TABLE_NAME = '[TableName]';':Unknown table 'COLUMN_STATISTICS' in information_schema (1109)이 오류는 MariaDB와 MySQL 버전 차이로 인해 발생하며 mysqldump 명령어가 information_schema 데이터베이스의 COLUMN_STATISTICS 테이블을 찾지 못해서 발생합니다.현재 우리의 DB구성은 mariaDB였기에 버전호환성 문제를 일으키는 것 같습니다.이를 해결하기 위해 –column-statistics=0 옵션을 추가하여 COLUMN_STATISTICS 기능을 비활성화할 수 있습니다.mysqldump --column-statistics=0 -uroot -p [password] [database] &gt; /tmp/[dumpFileName].sql2. 덤프 파일 존재 확인컨테이너 내부에서 덤프 파일이 잘 생성되었는지 확인합니다:ls -al /tmp/예상 출력 예시:root@[container_id]:/# ls -al /tmp/total 12drwxrwxrwt  2 root root 4096 May 21 12:00 .drwxr-xr-x 21 root root 4096 May 21 12:00 ..-rw-r--r--  1 root root 2048 May 21 12:00 [dumpedFileName].sql3.컨테이너에서 호스트로 덤프 파일 복사덤프파일이 생성된 컨테이너의 임시볼륨에 접근하고 SQL파일을 특정경로로 복사해줍니다sudo docker cp [container_id or container_name]:/tmp/[dumpedFileName].sql /home/ubuntu/[copyFileName].sql또는 현재 디렉토리에 복사하려면 다음과 같이 합니다:sudo docker cp 615ff7727e34:/tmp/backup0521.sql .요약이 과정을 통해 AWS 인스턴스의 Docker 컨테이너에서 MariaDB 데이터베이스 덤프 파일을 생성하고이를 호스트 머신으로 복사할 수 있습니다  Docker 컨테이너 내부에 접속  mysqldump 명령어를 사용하여 덤프 파일 생성  ls -al 명령어로 덤프 파일 존재 확인  docker cp 명령어로 덤프 파일을 호스트로 복사"
  },
  
  {
    "title": "Docker 이해하기:arm환경에서 Docker로 python서버 구성하기",
    "url": "/posts/Docker-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-arm%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-Docker%EB%A1%9C-python%EC%84%9C%EB%B2%84-%EA%B5%AC%EC%84%B1%ED%95%98%EA%B8%B0/",
    "categories": "docker",
    "tags": "docker",
    "date": "2024-05-15 00:00:00 +0900",
    





    
    "snippet": "Docker 소개Docker는 개발자들이 어디에서나 일관된 환경에서 애플리케이션을 실행할 수 있도록 컨테이너라는 형태로 소프트웨어를 패키징할 수 있는 플랫폼으로, 소프트웨어 개발에 혁명을 일으켰습니다. 이 글에서는 Docker가 등장한 배경, 그리고 컨테이너, 이미지, 볼륨, 빌드 프로세스 같은 주요 개념을 탐구하고, 이러한 개념들이 어떻게 효율적이고...",
    "content": "Docker 소개Docker는 개발자들이 어디에서나 일관된 환경에서 애플리케이션을 실행할 수 있도록 컨테이너라는 형태로 소프트웨어를 패키징할 수 있는 플랫폼으로, 소프트웨어 개발에 혁명을 일으켰습니다. 이 글에서는 Docker가 등장한 배경, 그리고 컨테이너, 이미지, 볼륨, 빌드 프로세스 같은 주요 개념을 탐구하고, 이러한 개념들이 어떻게 효율적이고 예측 가능한 소프트웨어 배포에 기여하는지 살펴보고 , ARM아키텍쳐로 구성된 로컬환경에서버전이 낮은 Python서버를 Docker로 구성하고 서버를 돌려봅니다..Docker의 등장Docker는 2013년에 도입되어, 서로 다른 컴퓨팅 환경에서 소프트웨어를 신뢰성 있게 구성하는 복잡성에 대응하였습니다. 컨테이너 기술을 활용하여 기반 인프라에 관계없이 코드가 동일하게 실행될 수 있도록 함으로써 개발, 테스트 및 배포 워크플로우를 단순화했습니다.주요 Docker 개념 이해컨테이너컨테이너는 코드, 런타임, 라이브러리 및 시스템 설정을 포함하여 애플리케이션 실행에 필요한 모든 것이 포함된 경량의 실행 가능한 패키지입니다. Docker 이미지를 기반으로 운영되며, 각 컨테이너는 서로 완전히 격리되어 있어 같은 호스트에서 실행되어도 서로 영향을 주지 않습니다. 컨테이너는 일시적인 상태를 가지며 실행 중일 때만 상태가 유지됩니다.이미지이미지는 컨테이너 실행에 필요한 파일과 설정이 포함된 불변의 스냅샷입니다. 컨테이너를 생성하는 데 사용되는 템플릿으로 생각할 수 있으며, 하나의 이미지에서 여러 컨테이너를 생성할 수 있습니다. 이미지는 대개 Dockerfile이라는 텍스트 문서를 통해 생성되며, 이 문서에는 컨테이너를 어떻게 구성할지에 대한 지시사항이 포함되어 있습니다.볼륨볼륨은 데이터를 컨테이너와 독립적으로 저장하고 관리할 수 있는 메커니즘입니다. 컨테이너는 일반적으로 불변하며 상태가 없지만, 볼륨을 사용하면 데이터를 영구적으로 저장하거나 여러 컨테이너 간에 공유할 수 있습니다. 볼륨은 호스트 시스템의 특정 부분에 데이터를 저장하며, 컨테이너가 삭제되어도 데이터는 유지됩니다.빌드 프로세스빌드 프로세스는 소스 코드로부터 Docker 이미지를 생성하는 과정입니다. Dockerfile에 정의된 지시사항을 순차적으로 실행하여 이미지의 새로운 계층을 추가하며, 이 계층들이 최종 이미지를 구성합니다. 이렇게 생성된 이미지는 재사용이 가능하며 다른 시스템에 쉽게 배포할 수 있습니다.Docker 이미지 준비이제 기본적인 도커의 개념에 대해 학습했다 믿고 python서버를 docker위에서 구동되는 방법에 대해 소개합니다.Docker를 사용하여 호환성 문제를 해결할 수 있는 Python 3.10 이미지를 준비합니다. Dockerfile을 작성하여 필요한 설정을 구성할 수 있습니다.Python 3.10 이미지를 기반으로 설정FROM python:3.10작업 디렉토리 설정WORKDIR /app의존성 파일 복사COPY requirements.txt .의존성 설치requirements.txt에는 사용중인 라이브러리의 의존성들이 담겨져 있습니다.RUN pip install -r requirements.txt애플리케이션 코드 복사COPY . .서버 실행CMD [\"python\", \"app.py\"]도커 이미지 빌드docker build -t my-python-app .도커 컨테이너실행docker run -p 7077:7077 my-python-app포트번호는 각자 REST API통신을 하기위해 합의된 번호를 사용합니다.도커 컨테이너가 잘 실행되는지 확인하기위해서 REST API를 날려보고 WireShark로 원활한 통신을 하는지 확인해 봅니다서버에서 미리 정의해둔 비지니스 로직을 실행하고 반환하는 값이 정상적입니다.위의 방식으로 7077 포트를 사용하는 파이썬 서버를 도커환경에서 구성하고 API를 실행시켜보았습니다.이로써 어떤 상황에도 서버를 원활하게 구동할 준비가 되었습니다!"
  },
  
  {
    "title": "Electron에서 alert 사용시 input 읽기 전용 문제 해결",
    "url": "/posts/Electron%EC%97%90%EC%84%9C%EC%9D%98-input%EC%9D%B4-%EC%9D%98%EB%8F%84%EC%B9%98%EC%95%8A%EA%B2%8C-readonly%EB%A1%9C-%EA%B0%95%EC%A0%9C%EB%90%98%EB%8A%94-%ED%98%84%EC%83%81/",
    "categories": "Electron, troubleshooting",
    "tags": "",
    "date": "2024-05-13 00:00:00 +0900",
    





    
    "snippet": "개요Electron 애플리케이션에서 alert() 함수를 사용할 때, input 태그가 읽기 전용으로 설정되는 현상이 종종 발생합니다. 이 현상은 Electron의 구조적 특성 때문에 나타나는 문제로, 이해를 돕기 위해 문제의 원인과 해결 방안을 상세히 설명하겠습니다.원인 분석Electron은 Chromium과 Node.js를 기반으로 하는데, 이는 ...",
    "content": "개요Electron 애플리케이션에서 alert() 함수를 사용할 때, input 태그가 읽기 전용으로 설정되는 현상이 종종 발생합니다. 이 현상은 Electron의 구조적 특성 때문에 나타나는 문제로, 이해를 돕기 위해 문제의 원인과 해결 방안을 상세히 설명하겠습니다.원인 분석Electron은 Chromium과 Node.js를 기반으로 하는데, 이는 Electron이 브라우저와 유사한 환경을 제공하지만, 일부 특성이 다르다는 것을 의미합니다. 일반적인 웹 브라우저에서는 alert(), prompt(), confirm() 같은 함수들이 동기적으로 실행되어, 사용자의 입력을 기다리는 동안 전체 렌더링 엔진을 멈춥니다. 그러나 Electron에서는 이러한 함수들이 메인 프로세스의 시스템 대화 상자를 통해 실행되며, 이 과정에서 렌더러 프로세스는 계속해서 비동기적으로 동작합니다.이 때문에, 메인 스레드가 시스템 모달을 실행하면서 렌더러 프로세스의 입력 필드 등이 일시적으로 읽기 전용 상태가 될 수 있습니다. 이는 메인 프로세스와 렌더러 프로세스가 독립적으로 작동하면서 발생하는 동기화 문제로 볼 수 있습니다.해결 방안비동기 대화 상자 사용하기Electron의 dialog 모듈을 사용하여 비동기적으로 메시지 박스를 표시할 수 있습니다. 이 방법은 렌더러 프로세스를 차단하지 않고 사용자의 입력을 받을 수 있습니다.const { dialog } = require(\"electron\");dialog  .showMessageBox({    type: \"info\",    title: \"Information\",    message: \"This is an important message.\"  })  .then((result) =&gt; {    console.log(result.response);  });사용자 정의 모달 구현하기HTML과 CSS를 활용하여 사용자 정의 모달을 만들어 사용하는 것도 좋은 방법입니다. 이는 UI/UX를 완전히 제어할 수 있으며, 기존의 웹 기술을 활용하므로 개발자에게 친숙합니다.&lt;div id=\"myModal\" class=\"modal\"&gt;  &lt;div class=\"modal-content\"&gt;    &lt;span class=\"close\"&gt;&amp;times;&lt;/span&gt;    &lt;p&gt;Some text in the Modal..&lt;/p&gt;  &lt;/div&gt;&lt;/div&gt;&lt;style&gt;.modal {    display: none;    position: fixed;    z-index: 1;    left: 0;    top: 0;    width: 100%;    height: 100%;    overflow: auto;    background-color: rgb(0,0,0);    background-color: rgba(0,0,0,0.4);}&lt;/style&gt;const modal = document.getElementById(\"myModal\");const span = document.getElementsByClassName(\"close\")[0];span.onclick = function() {    modal.style.display = \"none\";}window.onclick = function(event) {    if (event.target == modal) {        modal.style.display = \"none\";    }}결론Electron에서 alert() 함수의 사용은 입력 필드를 일시적으로 읽기 전용으로 만들 수 있습니다. 이 문제를 해결하기 위해 비동기 대화 상자 사용이나 사용자 정의 모달 구현을 추천합니다. 이 방법들을 통해 사용자 경험을 개선하고 애플리케이션의 효율성을 높일 수 있습니다.커스텀 alert나 modal, dialog 사용함으로써 Electron의 에러를 회피해야합니다. 처음 이 에러를 접하면 어떠한 동작때문인가 싶을텐데해당 이벤트(클릭,handler함수 실행의 사이드이페트)보단 alert그 자체의 문제였어서 당황하였습니다."
  },
  
  {
    "title": "Stencil에서 정적 파일을 이용한 SEO 최적화: RSS, Sitemap, Robots.txt 설정하기",
    "url": "/posts/stencil%EC%97%90%EC%84%9C-%EC%A0%95%EC%A0%81%ED%8C%8C%EC%9D%BC-%EC%B6%94%EA%B0%80%ED%95%B4-SEO%EC%B5%9C%EC%A0%81%ED%99%94%ED%95%98%EA%B8%B0/",
    "categories": "web-development, seo, stencil, vercel, deploy",
    "tags": "",
    "date": "2024-05-12 00:00:00 +0900",
    





    
    "snippet": "개요이 포스트에서는 Stencil 프로젝트에서 SEO를 향상시키기 위해 RSS, sitemap, 및 robots.txt 파일을 정적 파일로 추가하고, 이를 Vercel을 통해 배포하는 과정을 소개하려고 합니다.배경웹 개발에서 검색 엔진 최적화(SEO)는 매우 중요합니다. 효과적인 SEO 설정을 통해 검색 엔진에서 더 높은 순위를 얻고, 이로 인해 웹사...",
    "content": "개요이 포스트에서는 Stencil 프로젝트에서 SEO를 향상시키기 위해 RSS, sitemap, 및 robots.txt 파일을 정적 파일로 추가하고, 이를 Vercel을 통해 배포하는 과정을 소개하려고 합니다.배경웹 개발에서 검색 엔진 최적화(SEO)는 매우 중요합니다. 효과적인 SEO 설정을 통해 검색 엔진에서 더 높은 순위를 얻고, 이로 인해 웹사이트의 트래픽과 가시성이 증가할 수 있습니다.Stencil 프로젝트 설정Stencil은 웹 컴포넌트를 빌드하기 위한 도구이며, 다음과 같이 프로젝트를 설정합니다.  assets 디렉토리에 SEO 관련 파일을 저장합니다.  기본적으로 stencil읭 빌드 경로 www/assets/ 파일들이 해당 위치에 저장됩니다.  SEO폴더안의 정적, 혹은 동적으로 생성된 SEO 파일들을 vercel.json으로 라우팅처리를 해줍니다.파일 구조/www/assets/SEO/└──sitemap.xml└──rss.xml├── rss.xmlVercel에서의 배포Vercel을 사용하여 Stencil 프로젝트를 배포하는 과정은 다음과 같습니다.설정 파일 (vercel.json){  \"rewrites\": [    { \"source\": \"/sitemap.xml\", \"destination\": \"/assets/SEO/sitemap.xml\" },    { \"source\": \"/rss.xml\", \"destination\": \"/assets/SEO/rss.xml\" },    { \"source\": \"/robots.txt\", \"destination\": \"/assets/SEO/robots.txt\" }  ],  \"headers\": [    {      \"source\": \"/rss.xml\",      \"headers\": [        {          \"key\": \"Content-Type\",          \"value\": \"application/xml; charset=utf-8\"        }      ]    },    {      \"source\": \"/sitemap.xml\",      \"headers\": [        {          \"key\": \"Content-Type\",          \"value\": \"application/xml; charset=utf-8\"        }      ]    },    {      \"source\": \"/robots.txt\",      \"headers\": [        {          \"key\": \"Content-Type\",          \"value\": \"text/plain; charset=utf-8\"        },        {          \"key\": \"Cache-Control\",          \"value\": \"public, max-age=86400\"        }      ]    }  ]}라우팅과 파일 타입 설정위의 vercel.json 설정을 통해 각 파일에 적절한 Content-Type 헤더를 설정하고, 캐시 제어를 위한 Cache-Control 헤더를 추가하여 SEO를 최적화할 수 있습니다.마치며이 글에서는 Stencil과 Vercel을 사용하여 RSS, sitemap, 및 robots.txt 파일을 관리하고 SEO를 개선하는 방법을 알아보았습니다.사실은 위의 SEO적용에서의 시행착오가 많았습니다.프로젝트 루트에 해당파일을 위치시켜서 빌드하면 정적자산들이 제대로 빌드되지않는 현상을 겪었고,stencil에서의 정적자산들에 대한 기본위치는 리액트에서의 public처럼 assets에 위치해 있다는 사실을 파악하고vercel에서의 빌드설정파일인 vercel.json에서 최종적으로 자산에 대한 설정을 추가적으로 작업해줘야했습니다결론적으로 deploy되는 폴더인 www/assets/설정 및 저장한 폴더의 정적자산 PATH로 설정을 해줘야합니다..이 설정은 정적자산을 바탕으로 포스팅되었지만 해당 정적자산들을 동적으로 바꿔준다 하더라도 유효합니다."
  },
  
  {
    "title": "일렉트론에서의 서버 오류 핸들링",
    "url": "/posts/%EC%9D%BC%EB%A0%89%ED%8A%B8%EB%A1%A0%EC%97%90%EC%84%9C%EC%9D%98-%EC%84%9C%EB%B2%84-%ED%97%AC%EC%8A%A4%EC%B2%B4%ED%81%AC/",
    "categories": "Electron, Node.js, Socket Server",
    "tags": "Health Check, Server Handling, Socket Server, Electron, troubleshooting",
    "date": "2024-05-10 00:00:00 +0900",
    





    
    "snippet": "개요데이터베이스 백업 로직 중 DB에 센서의 신호값을 저장하거나 , 갖가지 정보 등의 데이터를 소켓 서버에서 참조하는 과정에서 데이터의 무결성을 잃는 현상이 발생했습니다.이로 인해 소켓 서버가 에러를 일으켜 실행되지 않는 오류가 발생했습니다.첫번째는 백업로직중 , 관련된 서버의 동작을 일시정지하는것이 우선되어야겠지만 저는 어느상황에서든지 서버의 이상을...",
    "content": "개요데이터베이스 백업 로직 중 DB에 센서의 신호값을 저장하거나 , 갖가지 정보 등의 데이터를 소켓 서버에서 참조하는 과정에서 데이터의 무결성을 잃는 현상이 발생했습니다.이로 인해 소켓 서버가 에러를 일으켜 실행되지 않는 오류가 발생했습니다.첫번째는 백업로직중 , 관련된 서버의 동작을 일시정지하는것이 우선되어야겠지만 저는 어느상황에서든지 서버의 이상을 감지하고 서버가 자동으로 재실행되는 항상성을 유지하고싶었습니다.따라서 헬스체크의 필요성을 느끼고 일렉트론에서 특정 주기마다 헬스체크를 진행하여 의도치 않은 모든 오류를 핸들링하는 로직을 구현했습니다.추후에 DB백업로직이 실행되면 관련로직의 Socket을 끊고 재연결하고, DB 저장을 일시정지하는 로직을 추가개발해야합니다.헬스체크 로직시스템 환경마다 서버의 실행시간을 예측하기란 어려운 일입니다. 프로그램이 요구하는 시스템의 최소사양에서의 서버실행시간의 평균값인 3초보다 여유를 둔 5초 단위로서비스가 실행되면 헬스체크 메세지를 날리고 , 해당메세지의 respanse Message가 돌아오지못한다면(서버가 원활하지못한다면) 서버를 재실행합니다.재실행은 5초에서 10초 , 20초 , 40초 최대 1분간 기다리며 , 모든 재실행이 실패한다면 dialog로 사용자에게 서버가 원활하지않음을 알립니다.일렉트론 파일에서의 헬스체크 로직// electron 파일에서의 헬스체크 로직let consecutiveFailures = 0;const INITIAL_INTERVAL = 5000;const MAX_INTERVAL = 60000; // 최대 재시작 간격 (60초)let currentInterval = INITIAL_INTERVAL;async function socketHealthCheck() {  if (socketProcess) {    socketProcess.send(\"check-health\");    const isHealthy = await new Promise((resolve) =&gt; {      const timer = setTimeout(() =&gt; {        resolve(false);      }, 5000);      socketProcess.once(\"message\", (message) =&gt; {        if (message === \"socket server health!\") {          clearTimeout(timer);          resolve(true);          console.log(\"socket OK!!\");        }      });    });    if (!isHealthy) {      console.log(\"Socket server is unhealthy, restart\");      await restartSocketServer();      consecutiveFailures += 1;      currentInterval = Math.min(currentInterval * 2, MAX_INTERVAL); // 간격을 두 배로 늘립니다.      mainWindow.reload();      // 연속 실패가 최대 허용 횟수를 초과하면 경고 대화상자를 표시합니다.      if (consecutiveFailures &gt;= MAX_CONSECUTIVE_FAILURES) {        dialog.showMessageBox({          type: \"warning\",          title: \"Socket Server Warning\",          message:            \"소켓 서버가 건강하지 않습니다. 문제가 지속되면 시스템 관리자에게 문의하세요.\",          buttons: [\"확인\"]        });      }    } else {      consecutiveFailures = 0;      currentInterval = INITIAL_INTERVAL; // 서버가 건강하면 간격을 초기화합니다.    }  }}async function restartSocketServer() {  if (socketProcess) {    socketProcess.kill();    socketProcess = null;    await socketStart();    console.log(\"Socket server restarted\");  }}// 일정 간격으로 소켓 서버의 건강을 확인하고, 실패할 경우 간격을 조정합니다.function scheduleHealthCheck() {  setTimeout(() =&gt; {    socketHealthCheck().then(() =&gt; {      scheduleHealthCheck(); // 다음 건강 점검을 스케줄링합니다.    });  }, currentInterval);}scheduleHealthCheck(); // 건강 점검을 시작합니다."
  }
  
]

